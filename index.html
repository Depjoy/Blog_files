<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>秋过冬漫长</title>
  <meta property="qc:admins" content="136042646177767140526177" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="郑超的个人博客，Charles&apos;s blog.">
<meta property="og:type" content="website">
<meta property="og:title" content="秋过冬漫长">
<meta property="og:url" content="http://chaooo.github.io/index.html">
<meta property="og:site_name" content="秋过冬漫长">
<meta property="og:description" content="郑超的个人博客，Charles&apos;s blog.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋过冬漫长">
<meta name="twitter:description" content="郑超的个人博客，Charles&apos;s blog.">
  <link rel="alternate" href="/atom.xml" title="秋过冬漫长" type="application/atom+xml">  
  <link rel="icon" href="/favicon.png">  
  <link href="http://fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> 
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div id="wrap">
      <!--[if lt IE 9]><div id="header"><![endif]-->
      <header id="header">
        <div id="banner"></div>
        <div id="header-outer" class="outer">
          <div id="header-title" class="inner">
            <h1 id="logo-wrap"><a href="/" id="logo">秋过冬漫长</a></h1>
             <h2 id="subtitle-wrap"><a href="/" id="subtitle">没有比脚更长的路，走下去，前面是个天！</a></h2> 
          </div>
          <div id="header-inner" class="inner">
            <nav id="main-nav">
              <a id="main-nav-toggle" class="nav-icon"></a>
               <a class="main-nav-link" href="/">Home</a>  <a class="main-nav-link" href="/archives">Archives</a>  <a class="main-nav-link" href="/baidusitemap.xml">baidusitemap</a> 
            </nav>
            <nav id="sub-nav">
              <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
               <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> 
            </nav>
            <div id="search-form-wrap">
              <form action="" method="get" accept-charset="UTF-8" class="search-form">
                <input autocapitalize="off" autocorrect="off" autocomplete="off" name="q" results="0" id="search" maxlength="20" placeholder="Search" style="border:none;background:none;width:161px;height:30px;line-height:30px;padding:0px 11px 0px 28px;" class="st-default-search-input search-form-input" type="text">
                <button type="submit" class="search-form-submit"></button>
              </form>
            </div>
          </div>
          <!--[if lt IE 9]>
            <style>.hid-ltIE9{position:absolute;bottom:0;left:0;z-index:999;width:100%;line-height:46px;color:#7b1a00;font-size:14px;text-align:center;background:#fff3c8;border-radius:4px;border:1px solid #;text-shadow:0 1px #fff;-webkit-box-shadow:0 -1px 4px #ccc inset;box-shadow:0 -1px 4px #ccc inset;border:1px solid #ccc;}.hid-ltIE9 a{color:#258fb8;text-decoration:none;}.hid-ltIE9 a:hover{text-decoration:underline;}.hid-exclamation-triangle,.hid-chrome,.hid-firefox{font:normal normal normal 14px/1 FontAwesome;display:inline-block;width:30px;height:30px;font-size:14px;text-align:center;}.hid-exclamation-triangle:before{content:"\f071";}.hid-chrome:before{content:"\f268";}.hid-firefox:before{content:"\f269";}</style><p class="hid-ltIE9"><i class="hid-exclamation-triangle" aria-hidden="true"></i>重要提示：您当前使用的浏览器版本过低，可能存在安全风险！想要更好的体验，建议升级浏览器：<a href="https://www.google.cn/intl/zh-CN/chrome/browser/desktop/" title="谷歌Chrome浏览器"><i class="hid-chrome" aria-hidden="true"></i>Chrome</a>、<a href="http://www.firefox.com.cn/download/"title="火狐Firefox浏览器"><i class="hid-firefox" aria-hidden="true"></i>Firefox</a></p>
          <![endif]-->
        </div>
      </header>
      <!--[if lt IE 9]></div><![endif]-->
      <div class="outer">
        <section id="main">
  
          <article id="post-NodeJs学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2016/06/27/NodeJs学习笔记.html" class="article-date">
                <time datetime="2016-06-27T03:55:07.000Z" itemprop="datePublished">2016-06-27</time>
              </a> 
            </div>
            <div class="article-inner">
              
              <header class="article-header">                
                <h1 itemprop="name">
                  <a class="article-title" href="/2016/06/27/NodeJs学习笔记.html">NodeJs学习笔记</a>
                </h1>
                
              </header>
              
              <div class="article-entry" itemprop="articleBody">
                
                <h3 id="1、Node-js创建第一个应用"><a href="#1、Node-js创建第一个应用" class="headerlink" title="1、Node.js创建第一个应用"></a>1、Node.js创建第一个应用</h3><h4 id="1-1、创建服务器"><a href="#1-1、创建服务器" class="headerlink" title="1.1、创建服务器"></a>1.1、创建服务器</h4><p>使用 <code>http.createServer()</code> 方法创建服务器，并使用 <code>listen</code> 方法绑定 8888 端口。 函数通过 <code>request</code>, <code>response</code> 参数来接收和响应数据。实例如下，在项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);<span class="comment">//引入require模块</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">require, response</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//发送 HTTP 头部</span></span><br><span class="line">  <span class="comment">//HTTP 状态值：200：OK</span></span><br><span class="line">  <span class="comment">//内容类型：text/plain</span></span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  <span class="comment">//发送响应数据：“Hello World”</span></span><br><span class="line">  response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">//终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用 node 命令执行以上的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br><span class="line">Server running at http://127.0.0.1:8888/</span><br></pre></td></tr></table></figure></p>
<p>接下来，打开浏览器访问 <code>http://127.0.0.1:8888/</code>，你会看到一个写着 “Hello World” 的网页。</p>
<h3 id="2、Node-js-事件循环"><a href="#2、Node-js-事件循环" class="headerlink" title="2、Node.js 事件循环"></a>2、Node.js 事件循环</h3><p>Node.js 有多个内置的事件，我们可以通过引入 <code>events</code> 模块，并通过实例化 <code>EventEmitter</code> 类来绑定和监听事件，如下实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入events模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">//创建eventEmitter对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="comment">//创建时间处理程序</span></span><br><span class="line"><span class="keyword">var</span> connectHander = <span class="function"><span class="keyword">function</span> <span class="title">connected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接成功。'</span>);</span><br><span class="line">  <span class="comment">//触发data_received事件</span></span><br><span class="line">  eventEmitter.emit(<span class="string">'data_received'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定connection事件处理程序</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, connectHandler);</span><br><span class="line"><span class="comment">//使用匿名函数绑定data_received事件</span></span><br><span class="line">eventEmitter.on(<span class="string">'data_received'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据接收成功。'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//触发connection事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="node应用程序如何工作"><a href="#node应用程序如何工作" class="headerlink" title="node应用程序如何工作"></a>node应用程序如何工作</h5><p>创建一个input.txt文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World;</span><br></pre></td></tr></table></figure></p>
<p>创建main.js文件，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上程序中 <code>fs.readFile()</code> 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们删除 input.txt 文件，执行结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">Error: ENOENT, open &apos;input.txt&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、Node-js-EventEmitter-类"><a href="#3、Node-js-EventEmitter-类" class="headerlink" title="3、Node.js EventEmitter 类"></a>3、Node.js EventEmitter 类</h3><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。<br>Node.js里面的许多对象都会分发事件：一个<code>net.Server</code> 对象会在每次有新连接时分发一个事件， 一个<code>fs.readStream</code>对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例。<br><code>events</code> 模块只提供了一个对象： <code>events.EventEmitter</code>。<code>EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。<br>你可以通过<code>require(&quot;events&quot;)</code>;来访问该模块:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">//创建eventEmitter对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure></p>
<p><code>EventEmitter</code> 对象如果在实例化时发生错误，会触发 <code>&#39;error&#39;</code> 事件。当添加新的监听器时，<code>&#39;newListener&#39;</code> 事件会触发，当监听器被移除时，<code>&#39;removeListener&#39;</code> 事件被触发。实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">event.on(<span class="string">'some_event'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event事件触发'</span>)；</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  event.emit(<span class="string">'some_event'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行这段代码，1 秒后控制台输出了 <code>some_event 事件触发</code>。其原理是 <code>event</code> 对象注册了事件 <code>some_event</code> 的一个监听器，然后我们通过 <code>setTimeout</code> 在 1000 毫秒以后向 <code>event</code> 对象发送事件 <code>some_event</code>，此时会调用<code>some_event</code> 的监听器<br>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node event.js </span><br><span class="line">some_event 事件触发</span><br></pre></td></tr></table></figure></p>
<p><code>EventEmitter</code> 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，<code>EventEmitter</code> 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>emitter</code> 为事件 <code>someEvent</code> 注册了两个事件监听器，然后触发了 <code>someEvent</code> 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是<code>EventEmitter</code>最简单的用法。<code>EventEmitter</code> 提供了多个属性，如 <code>on</code> 和 <code>emit</code>。<code>on</code> 函数用于绑定事件函数，<code>emit</code> 属性用于触发一个事件。<br>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node event.js </span><br><span class="line">listener1 arg1 参数 arg2 参数</span><br><span class="line">listener2 arg1 参数 arg2 参数</span><br></pre></td></tr></table></figure></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>1、<code>addListener(event, listener)</code>//为指定事件添加一个监听器到监听数组的尾部<br>2、<code>on(event, listener)</code>//为指定事件注册一个监听器，接受一个字符串 <code>event</code> 和一个回调函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3、<code>once(event, listener)</code>//为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.once(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Ah, we have our first user!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>4、<code>removeListener(event, listener)</code>//移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">server.on(<span class="string">'connection'</span>, callback);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">server.removeListener(<span class="string">'connection'</span>, callback);</span><br></pre></td></tr></table></figure></p>
<p>5、<code>removeAllListeners([event])</code>//移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。<br>6、<code>setMaxListeners(n)</code>//默认情况下， <code>EventEmitters</code> 如果你添加的监听器超过 10 个就会输出警告信息。 <code>setMaxListeners</code> 函数用于提高监听器的默认限制的数量。<br>7、<code>listeners(event)</code>//返回指定事件的监听器数组<br>8、<code>emit(event, [arg1], [arg2], [...])</code>//按参数的顺序执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>1、<code>listenerCount(emitter, event)</code>//返回指定事件的监听器数量。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>1、<code>newListener</code> //该事件再添加新监听器时被触发<br>  <code>event</code> - 字符串，事件名称<br>  <code>listener</code> - 处理事件函数<br>2、<code>removeListener</code>//从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。<br>  <code>event</code> - 字符串，事件名称<br>  <code>listener</code> - 处理事件函数<br>实例：通过 <code>connection</code>（连接）事件演示了 <code>EventEmitter</code> 类的应用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建main.js文件：</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener1 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener2 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定connection事件，处理函数为listener1</span></span><br><span class="line">eventEmitter.addListener(<span class="string">'connection'</span>,listener1);</span><br><span class="line"><span class="comment">// 绑定connection事件，处理函数为listener2</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>,listener2);</span><br><span class="line"><span class="keyword">var</span> eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">"个监听器连接事件"</span>);</span><br><span class="line"><span class="comment">//处理connection事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"><span class="comment">//移除监绑定的listener1函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">'connection'</span>,listener1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listener1不再受监听。"</span>);</span><br><span class="line"><span class="comment">//触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line">eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">"个监听器连接事件"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure></p>
<p>//执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line">2个监听器连接事件</span><br><span class="line">监听器 listener1 执行。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">listener1不再受监听。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">1个监听器连接事件</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure></p>
<h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><p><code>EventEmitter</code> 定义了一个特殊的事件 <code>error</code>，它包含了错误的语义，我们在遇到 异常的时候通常会触发 <code>error</code> 事件。当 <code>error</code> 被触发时，<code>EventEmitter</code> 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 <code>error</code> 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<h4 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h4><p>大多数时候我们不会直接使用 <code>EventEmitter</code>，而是在对象中继承它。包括 <code>fs、net、 http</code> 在内的，只要是支持事件响应的核心模块都是 <code>EventEmitter</code>的子类。<br>原因有两点：<br>  -首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>  -其次 <code>JavaScript</code> 的对象机制是基于原型的，支持 部分多重继承，继承 <code>EventEmitter</code> 不会打乱对象原有的继承关系。</p>
<h3 id="4、Node-js-Buffer-缓冲区"><a href="#4、Node-js-Buffer-缓冲区" class="headerlink" title="4、Node.js Buffer(缓冲区)"></a>4、Node.js Buffer(缓冲区)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。一个 <code>Buffer</code> 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h4 id="创建Buffer类"><a href="#创建Buffer类" class="headerlink" title="创建Buffer类"></a>创建Buffer类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">10</span>);<span class="comment">//创建长度为10字节的Buffer实例</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);<span class="comment">//通过给定的数组创建Buffer实例</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="string">"www.runoob.com"</span>, <span class="string">"utf-8"</span>);<span class="comment">//通过一个字符串来创建Buffer实例</span></span><br></pre></td></tr></table></figure>
<h4 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding]);</span><br></pre></td></tr></table></figure>
<p>参数：<br>  <code>string</code> - 写入缓冲区的字符串。<br>  <code>offset</code> - 缓冲区开始写入的索引值，默认为0.<br>  <code>length</code> - 写入的字节数，默认为buffer.length<br>  <code>encoding</code> - 使用的编码。默认‘utf-8’<br>返回值：返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<h4 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>
<p>参数：<br>  <code>encoding</code> - 使用的编码。默认‘utf-8’.<br>  <code>start</code> - 指定开始读取的索引位置，默认为0.<br>  <code>end</code> - 结束位置，默认缓冲区末尾。<br>返回值：解码缓冲区数据并使用指定的编码返回字符串。</p>
<h4 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toJSON();</span><br></pre></td></tr></table></figure>
<p>返回值：返回JSON对象。</p>
<h4 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat(list, [totalLength]);</span><br></pre></td></tr></table></figure>
<p>参数：<br>  <code>list</code> - 用于合并的Buffer对象数组列表。<br>  <code>totalLength</code> - 指定合并后Buffer对象的总长度。<br>返回值：返回一个多个成员合并的新 Buffer 对象。</p>
<h4 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.compare(otherBuffer);</span><br></pre></td></tr></table></figure>
<p>返回值：返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</p>
<h4 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]);</span><br></pre></td></tr></table></figure>
<p>参数：<br>  <code>targetBuffer</code> - 要拷贝的 Buffer 对象。<br>   <code>targetStart</code> - 数字, 可选, 默认: 0<br>   <code>sourceStart</code> - 数字, 可选, 默认: 0<br>     <code>sourceEnd</code> - 数字, 可选, 默认: buffer.length<br>返回值：无。</p>
<h4 id="缓冲区剪裁"><a href="#缓冲区剪裁" class="headerlink" title="缓冲区剪裁"></a>缓冲区剪裁</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.slice([start],[end]);</span><br></pre></td></tr></table></figure>
<p>参数：<br>  <code>start</code> - 数字, 可选, 默认: 0<br>  <code>end</code> - 数字, 可选, 默认: buffer.length<br>返回值：返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>
<h4 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.length;</span><br></pre></td></tr></table></figure>
<p>返回值：返回Buffer对象所占据的内存长度。</p>
<h4 id="Node-js-Buffer-模块常用的方法"><a href="#Node-js-Buffer-模块常用的方法" class="headerlink" title="Node.js Buffer 模块常用的方法"></a>Node.js Buffer 模块常用的方法</h4><p>  <code>new Buffer(size)</code>;//分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。<br>  <code>new Buffer(buffer)</code>;//拷贝参数 buffer 的数据到 Buffer 实例。<br>  <code>new Buffer(str, [encoding])</code>;//分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。<br>  <code>buf.length</code>;//返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。<br>  <code>buf.toString([encoding], [start], [end])</code>;//根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。<br>  <code>buf.toJSON()</code>;//将 Buffer 实例转换为 JSON 对象。<br>  <code>buf[index]</code>;//获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。<br>  <code>buf.equals(otherBuffer)</code>;//比较两个缓冲区是否相等，如果是返回 true，否则返回 false。<br>  <code>buf.compare(otherBuffer)</code>;//比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。<br>  <code>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</code>;//buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。<br>  <code>buf.slice([start, [end]])</code>;//剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。<br>  <code>buf.fill(value, [offset], [end])</code>;//使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。<br>  <code>buf.write(string, [offset], [length], [encoding])</code>;//根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。<br>  <code>buf.writeUIntLE(value, offset, byteLength, [noAssert])</code>;//将value 写入到 buffer 里， 它由offset 和 byteLength 决定。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。/<em> 下同。</em>/<br>  <code>buf.writeUIntBE(value, offset, byteLength, [noAssert])</code>;<br>  <code>buf.writeUInt8(value, offset, [noAssert])</code>;<br>  <code>buf.writeUInt16LE(value, offset, [noAssert])</code>;<br>  <code>buf.writeUInt16BE(value, offset, [noAssert])</code>;<br>  <code>buf.writeUInt32LE(value, offset, [noAssert])</code>;<br>  <code>buf.writeUInt32BE(value, offset, [noAssert])</code>;<br>  <code>buf.writeIntLE(value, offset, byteLength, [noAssert])</code>;<br>  <code>buf.writeIntBE(value, offset, byteLength, [noAssert])</code>;<br>  <code>buf.writeInt8(value, offset, [noAssert])</code>;<br>  <code>buf.writeInt16LE(value, offset, [noAssert])</code>;<br>  <code>buf.writeInt16BE(value, offset, [noAssert])</code>;<br>  <code>buf.writeInt32LE(value, offset, [noAssert])</code>;<br>  <code>buf.writeInt32BE(value, offset, [noAssert])</code>;<br>  <code>buf.writeFloatLE(value, offset, [noAssert])</code>;<br>  <code>buf.writeFloatBE(value, offset, [noAssert])</code>;<br>  <code>buf.writeDoubleLE(value, offset, [noAssert])</code>;<br>  <code>buf.writeDoubleBE(value, offset, [noAssert])</code>;<br>  <code>buf.readUInt8(offset, [noAssert])</code>;//读取。<br>  <code>buf.readUInt16LE(offset, [noAssert])</code>;<br>  <code>buf.readUInt16BE(offset, [noAssert])</code>;<br>  <code>buf.readUInt32LE(offset, [noAssert])</code>;<br>  <code>buf.readUInt32BE(offset, [noAssert])</code>;<br>  <code>buf.readUIntLE(offset, byteLength, [noAssert])</code>;<br>  <code>buf.readUIntBE(offset, byteLength, [noAssert])</code>;<br>  <code>buf.readIntLE(offset, byteLength, [noAssert])</code>;<br>  <code>buf.readIntBE(offset, byteLength, [noAssert])</code>;<br>  <code>buf.readInt8(offset, [noAssert])</code>;<br>  <code>buf.readInt16LE(offset, [noAssert])</code>;<br>  <code>buf.readInt16BE(offset, [noAssert])</code>;<br>  <code>buf.readInt32LE(offset, [noAssert])</code>;<br>  <code>buf.readInt32BE(offset, [noAssert])</code>;<br>  <code>buf.readFloatLE(offset, [noAssert])</code>;<br>  <code>buf.readFloatBE(offset, [noAssert])</code>;<br>  <code>buf.readDoubleLE(offset, [noAssert])</code>;<br>  <code>buf.readDoubleBE(offset, [noAssert])</code>;</p>
<h3 id="5、Node-js-Stream-流"><a href="#5、Node-js-Stream-流" class="headerlink" title="5、Node.js Stream(流)"></a>5、Node.js Stream(流)</h3><p><code>Stream</code> 是一个抽象接口，<code>Node</code> 中有很多对象实现了这个接口。例如，对<code>http</code> 服务器发起请求的<code>request</code> 对象就是一个 <code>Stream</code>，还有<code>stdout</code>（标准输出）。<br>Stream有四种流类型：<br>  <code>Readable</code> //可读操作。<br>  <code>Writable</code> //可写操作。<br>  <code>Duplex</code>   //可读写操作。<br>  <code>Transform</code>//操作被写入数据，然后读出数据。<br>所有的<code>Stream</code>对象都是<code>EventEmitter</code>的实例。<br>常用事件：<br>      <code>data</code>  //当有数据可读时触发。<br>      <code>end</code> //没有更多数据可读时触发。<br>      <code>error</code> //在接收和写入过程中发生错误时触发。<br>      <code>finish</code>//所有数据已被写入到底层系统时触发。</p>
<h4 id="从流中读取数据实例"><a href="#从流中读取数据实例" class="headerlink" title="从流中读取数据实例"></a>从流中读取数据实例</h4><p>创建input.txt文件，内容自定。<br>创建main.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="comment">//设置编码为 utf8。</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</span><br><span class="line"><span class="comment">//处理流事件--&gt;data,end,and errror</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">  data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="写入流实例"><a href="#写入流实例" class="headerlink" title="写入流实例"></a>写入流实例</h4><p>创建main.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'我是被写入的数据'</span>;</span><br><span class="line"><span class="comment">//创建一个可以写入的流，写入到output.txt中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"><span class="comment">//使用utf8编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</span><br><span class="line"><span class="comment">//标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"><span class="comment">//处理流事件--&gt;finish, errror</span></span><br><span class="line">readerStream.on(<span class="string">'finish'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>####　管道流实例<br>创建input.txt文件，内容自定。<br>创建main.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">//创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="comment">//创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"><span class="comment">//管道读写操作，读取input.txt内容，并写入到output.txt文件中。</span></span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>####　链式流实例<br>创建compress.js文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="comment">//压缩input.txt文件为input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt'</span>).pipe(zlib.createGzip()).pipe(fs.createWriteStream(<span class="string">'input.txt.gz'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件压缩完成。"</span>);</span><br><span class="line"><span class="comment">//执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件</span></span><br><span class="line"><span class="comment">//创建 decompress.js 文件:</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="comment">//解压input.txt.gz文件为input.txt</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>).pipe(zlib.createGunzip()).pipe(fs.createWriteStream(<span class="string">'input.txt'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件解压完成。"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="6、Node-js模块系统"><a href="#6、Node-js模块系统" class="headerlink" title="6、Node.js模块系统"></a>6、Node.js模块系统</h3><p>Node.js 提供了<code>exports</code> 和 <code>require</code> 两个对象，其中 <code>exports</code> 是模块公开的接口，<code>require</code> 用于从外部获取一个模块的接口，即所获取模块的 <code>exports</code> 对象。<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>)</span>&#123;</span><br><span class="line">    name = thyName;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span>+ name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line">hello = <span class="keyword">new</span> Hello();</span><br><span class="line">hello.setName(<span class="string">'BYVoid'</span>);</span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></p>
<h4 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h4><p>我们已经在代码中使用了模块了。像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line">...</span><br><span class="line">http.createServer(...);</span><br></pre></td></tr></table></figure></p>
<p>Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有 <code>http</code> 模块所提供的公共方法的对象。<br>Node.js 的 <code>require</code>方法中的文件查找策略如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">开始require--&gt;</span><br><span class="line">  if (在文件模块缓存区中) &#123;</span><br><span class="line">    返回exports.</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    if (是原生模块) &#123;</span><br><span class="line">      if (在原生模块缓存区中) &#123;</span><br><span class="line">        返回exports.</span><br><span class="line">      &#125; else&#123;</span><br><span class="line">        加载原生模块--&gt;缓存原生模块--&gt;返回exports.</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      查找文件模块--&gt;根据扩展名载入文件模块--&gt;缓存文件模块--&gt;返回exports.</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h4><p>尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。</p>
<h4 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载 */"></a>从原生模块加载 */</h4><p>原生模块的优先级仅次于文件模块缓存的优先级。<code>require</code>方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个<code>http/http.js/http.node/http.json</code>文件，<code>require(&quot;http&quot;)</code>都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>
<h4 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载 */"></a>从文件加载 */</h4><p>当文件模块缓存中不存在，而且不是原生模块的时候，<code>Node.js</code>会解析<code>require</code>方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。<br><code>require</code>方法接受以下几种参数的传递:<br>  <code>http、fs、path</code>等，原生模块。<br>  <code>./mod</code>或<code>../mod</code>，相对路径的文件模块。<br>  <code>/pathtomodule/mod</code>，绝对路径的文件模块。<br>  <code>mod</code>，非原生模块的文件模块。</p>
<h3 id="7、Node-js函数"><a href="#7、Node-js函数" class="headerlink" title="7、Node.js函数"></a>7、Node.js函数</h3><p>Node.js中函数的使用与Javascript类似:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line">execute(say, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，我们把 <code>say</code> 函数作为<code>execute</code>函数的第一个变量进行了传递。这里返回的不是 <code>say</code> 的返回值，而是 <code>say</code> 本身！ 这样一来， <code>say</code> 就变成了<code>execute</code> 中的本地变量 <code>someFunction</code> ，<code>execute</code>可以通过调用 <code>someFunction()</code> （带括号的形式）来使用 <code>say</code> 函数。 当然，因为 <code>say</code> 有一个变量， <code>execute</code> 在调用 <code>someFunction</code> 时可以传递这样一个变量。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>)</span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line">execute(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;<span class="built_in">console</span>.log(word)&#125;, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们在 <code>execute</code> 接受第一个参数的地方直接定义了我们准备传递给 <code>execute</code> 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>
<h4 id="函数传递是如何让HTTP服务器工作的"><a href="#函数传递是如何让HTTP服务器工作的" class="headerlink" title="函数传递是如何让HTTP服务器工作的"></a>函数传递是如何让HTTP服务器工作的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<h3 id="8、Node-js-路由"><a href="#8、Node-js-路由" class="headerlink" title="8、Node.js 路由"></a>8、Node.js 路由</h3><p>我们要为路由提供请求的<code>URL</code>和其他需要的<code>GET</code>及<code>POST</code>参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看<code>HTTP</code>请求，从中提取出请求的<code>URL</code>以及<code>GET/POST</code>参数。我们需要的所有数据都会包含在<code>request</code>对象中，该对象作为<code>onRequest()</code>回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的<code>Node.JS</code>模块，它们分别是<code>url</code>和<code>querystring</code>模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                   url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http:<span class="comment">//localhost:8888/start?foo=bar&amp;hello=world</span></span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring(string)[<span class="string">"foo"</span>]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring(string)[<span class="string">"hello"</span>]</span><br></pre></td></tr></table></figure></p>
<p>当然我们也可以用<code>querystring</code>模块来解析<code>POST</code>请求体中的参数，稍后会有演示。<br>现在我们来给<code>onRequest()</code>函数加上一些逻辑，用来找出浏览器请求的<code>URL</code>路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">"received."</span>);</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以来编写路由了，建立一个名为<code>router.js</code>的文件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure></p>
<p>在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来(我们将使用依赖注入的方式较松散地添加路由模块)。首先，我们来扩展一下服务器的<code>start()</code>函数，以便将路由函数作为参数传递过去：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">"received."</span>);</span><br><span class="line">    route(pathname);<span class="comment">//路由函数</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure></p>
<p>同时，我们会相应扩展<code>index.js</code>，使得路由函数可以被注入到服务器中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure></p>
<p>现在启动应用（<code>node index.js</code>），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br><span class="line">Request <span class="keyword">for</span> /foo received.</span><br><span class="line">About to route a request <span class="keyword">for</span> /foo</span><br><span class="line"><span class="comment">//以上输出已经去掉了比较烦人的`/favicon.ico`请求相关的部分。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="9、Node-js-全局对象"><a href="#9、Node-js-全局对象" class="headerlink" title="9、Node.js 全局对象"></a>9、Node.js 全局对象</h3><p>在浏览器 <code>JavaScript</code> 中，通常 <code>window</code> 是全局对象， 而 <code>Node.js</code> 中的全局对象是 <code>global</code>，所有全局变量（除了 <code>global</code>本身以外）都是 <code>global</code> 对象的属性。 在 <code>Node.js</code> 我们可以直接访问到 <code>global</code> 的属性，而不需要在应用中包含它。</p>
<h4 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h4><p><code>global</code> 全局对象最根本的作用是作为全局变量的宿主。按照 <code>ECMAScript</code> 的定义，满足以下条 件的变量是全局变量：<br>  -在最外层定义的变量；<br>  -全局对象的属性；<br>  -隐式定义的变量（未定义直接赋值的变量）。<br>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p>
<h5 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h5><p><code>__filename</code>表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。<br>实例：创建<code>main.js</code>：<br>输出全局变量 <code>__filename</code> 的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( __filename );</span><br></pre></td></tr></table></figure></p>
<p>执行 main.js 文件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line">/web/com/runoob/nodejs/main.js</span><br></pre></td></tr></table></figure></p>
<h5 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h5><p><code>__dirname</code> 表示当前执行脚本所在的目录。<br>实例：创建<code>main.js</code>：<br>输出全局变量 <code>__dirname</code> 的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( __dirname );</span><br></pre></td></tr></table></figure></p>
<p>执行 main.js 文件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line">/web/com/runoob/nodejs</span><br></pre></td></tr></table></figure></p>
<h5 id="setTimeout-cb-ms"><a href="#setTimeout-cb-ms" class="headerlink" title="setTimeout(cb, ms)"></a>setTimeout(cb, ms)</h5><p><code>setTimeout(cb, ms)</code> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：<code>setTimeout()</code>只执行一次指定函数。返回一个代表定时器的句柄值。<br>实例:创建文件 main.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两秒后执行以上函数</span></span><br><span class="line">setTimeout(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>//执行 main.js 文件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></p>
<h5 id="clearTimeout-t"><a href="#clearTimeout-t" class="headerlink" title="clearTimeout(t)"></a>clearTimeout(t)</h5><p>clearTimeout(t) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的计算器。<br>实例:创建文件 main.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两秒后执行以上函数</span></span><br><span class="line"><span class="keyword">var</span> t = setTimeout(printHello, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">//清除定时器</span></span><br><span class="line">clearTimeout(t)</span><br></pre></td></tr></table></figure></p>
<p>执行 main.js 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br></pre></td></tr></table></figure></p>
<h5 id="setInterval-cb-ms-clearInterval-t"><a href="#setInterval-cb-ms-clearInterval-t" class="headerlink" title="setInterval(cb, ms), clearInterval(t)"></a>setInterval(cb, ms), clearInterval(t)</h5><p><code>setInterval(cb, ms)</code> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。可以使用 <code>clearInterval(t)</code> 函数来清除定时器。<code>setInterval()</code> 方法会不停地调用函数，直到 <code>clearInterval()</code> 被调用或窗口被关闭。<br>实例:创建文件 main.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两秒后执行以上函数</span></span><br><span class="line">setInterval(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>执行 main.js 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line">Hello, World! Hello, World! Hello, World ……</span><br></pre></td></tr></table></figure></p>
<p>以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 <code>ctrl + c</code> 按钮.</p>
<h5 id="console"><a href="#console" class="headerlink" title="console"></a>console</h5><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。<br>console方法：<br>-<code>console.log([data], [...])</code>//向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。<br>-<code>console.info([data], [...])</code>//P该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。<br>-<code>console.error([data], [...])</code>//输出错误消息的。控制台在出现错误时会显示是红色的叉子。<br>-<code>console.warn([data], [...])</code>//输出警告消息。控制台出现有黄色的惊叹号。<br>-<code>console.dir(obj, [options])</code>//用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。<br>-<code>console.time(label)</code>//输出时间，表示计时开始。<br>-<code>console.timeEnd(label)</code>//结束时间，表示计时结束。<br>-<code>console.trace(message, [...])</code>//当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。<br>-<code>console.assert(value, [message], [...])</code>//用于判断某个表达式或变量是否为真，接手两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</p>
<h5 id="process"><a href="#process" class="headerlink" title="process"></a>process</h5><p><code>process</code> 是一个全局变量，即 <code>global</code> 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。</p>
<h6 id="process-对象的一些最常用的成员方法"><a href="#process-对象的一些最常用的成员方法" class="headerlink" title="process 对象的一些最常用的成员方法:"></a>process 对象的一些最常用的成员方法:</h6><p>-<code>exit</code>//当进程准备退出时触发。<br>-<code>beforeExit</code>//当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。<br>-<code>uncaughtException</code>//当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。<br>-<code>Signal</code> 事件//当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。<br>-退出状态码：1,2,3,4,5,6,7,8,9,10,12,&gt;128</p>
<h6 id="Process属性："><a href="#Process属性：" class="headerlink" title="Process属性："></a>Process属性：</h6><p>-<code>stdout</code>//标准输出流。<br>-<code>stderr</code>//标准错误流<br>-<code>stdin</code>//标准输入流。<br>-<code>argv</code>//argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。<br>-<code>execPath</code>//返回执行当前脚本的 Node 二进制文件的绝对路径。<br>-<code>execArgv</code>//返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。<br>-<code>env</code>//返回一个对象，成员为当前 shell 的环境变量<br>-<code>exitCode</code>//进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。<br>-<code>version</code>//Node 的版本，比如v0.10.18。<br>-<code>versions</code>//一个属性，包含了 node 的版本和依赖.<br>-<code>config</code>//一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。<br>-<code>pid</code>//当前进程的进程号。<br>-<code>title</code>//进程名，默认值为”node”，可以自定义该值。<br>-<code>arch</code>//当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。<br>-<code>platform</code>//运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’<br>-<code>mainModule</code>//require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</p>
<h5 id="方法参考手册"><a href="#方法参考手册" class="headerlink" title="方法参考手册:"></a>方法参考手册:</h5><p>-<code>abort()</code>//这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。<br>-<code>chdir(directory)</code>//改变当前工作进程的目录，如果操作失败抛出异常。<br>-<code>cwd()</code>//返回当前进程的工作目录<br>-<code>exit([code])</code>//使用指定的 code 结束进程。如果忽略，将会使用 code 0。<br>-<code>getgid()</code>//获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>setgid(id)</code>//设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。<br>//注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>getuid()</code>//获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>setuid(id)</code>//设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。<br>//注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>getgroups()</code>//返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>setgroups(groups)</code>//设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>initgroups(user, extra_group)</code>//读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。<br>-<code>kill(pid, [signal])</code>//发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。<br>-<code>memoryUsage()</code>//返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。<br>-<code>nextTick(callback)</code>//一旦当前事件循环结束，调用回到函数。<br>-<code>umask([mask])</code>//设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。<br>-<code>uptime()</code>//返回 Node 已经运行的秒数。<br>-<code>hrtime()</code>//返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</p>
<h3 id="10、Node-js-常用工具"><a href="#10、Node-js-常用工具" class="headerlink" title="10、Node.js 常用工具"></a>10、Node.js 常用工具</h3><p><code>util</code> 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<h4 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h4><p><code>util.inherits(constructor, superConstructor)</code>//是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。<br>在这里我们只介绍<code>util.inherits</code> 的用法，示例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'base'</span>;</span><br><span class="line">  <span class="keyword">this</span>.base = <span class="number">1991</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; </span><br><span class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'sub'</span>;</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Sub, Base);</span><br><span class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base();</span><br><span class="line">objBase.showName();</span><br><span class="line">objBase.sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(objBase);</span><br><span class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub();</span><br><span class="line">objSub.showName();</span><br><span class="line"><span class="built_in">console</span>.log(objSub);</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过<code>util.inherits</code> 实现继承。运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base </span><br><span class="line">Hello base </span><br><span class="line">&#123; name: &apos;base&apos;, base: 1991, sayHello: [Function] &#125; </span><br><span class="line">sub </span><br><span class="line">&#123; name: &apos;sub&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出.</p>
<h4 id="util-inspect"><a href="#util-inspect" class="headerlink" title="util.inspect"></a>util.inspect</h4><p><code>util.inspect(object,[showHidden],[depth],[colors])</code>//是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。<br>-<code>showHidden</code>//是一个可选参数，如果值为 true，将会输出更多隐藏信息。<br>-<code>depth</code>//表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。<br>-<code>colors</code>//如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。<br>特别要指出的是，<code>util.inspect</code> 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'byvoid'</span>;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj));</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj,<span class="literal">true</span>));</span><br><span class="line"><span class="comment">//运行结果是： </span></span><br><span class="line">Person &#123; name: <span class="string">'byvoid'</span>, toString: [<span class="built_in">Function</span>] &#125;</span><br><span class="line">Person &#123;</span><br><span class="line">  name: <span class="string">'byvoid'</span>,</span><br><span class="line">  toString:</span><br><span class="line">   &#123; [<span class="built_in">Function</span>]</span><br><span class="line">     [length]: <span class="number">0</span>,</span><br><span class="line">     [name]: <span class="string">''</span>,</span><br><span class="line">     [<span class="built_in">arguments</span>]: <span class="literal">null</span>,</span><br><span class="line">     [caller]: <span class="literal">null</span>,</span><br><span class="line">     [prototype]: &#123; [<span class="keyword">constructor</span>]: [Circular] &#125; </span><br><span class="line">  &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="util-isArray"><a href="#util-isArray" class="headerlink" title="util.isArray"></a>util.isArray</h4><p><code>util.isArray(object)</code>//如果给定的参数 “object” 是一个数组返回true，否则返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">util.isArray([]);<span class="comment">// true</span></span><br><span class="line">util.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>);<span class="comment">// true</span></span><br><span class="line">util.isArray(&#123;&#125;);<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="util-isRegExp"><a href="#util-isRegExp" class="headerlink" title="util.isRegExp"></a>util.isRegExp</h4><p><code>util.isRegExp(object)</code>//如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">util.isRegExp(<span class="regexp">/some regexp/</span>);<span class="comment">// true</span></span><br><span class="line">util.isRegExp(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'another regexp'</span>));<span class="comment">// true</span></span><br><span class="line">util.isRegExp(&#123;&#125;);<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="util-isDate"><a href="#util-isDate" class="headerlink" title="util.isDate"></a>util.isDate</h4><p><code>util.isDate(object)</code>// 如果给定的参数 “object” 是一个日期返回true，否则返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>());<span class="comment">// true</span></span><br><span class="line">util.isDate(<span class="built_in">Date</span>());<span class="comment">// false (without 'new' returns a String)</span></span><br><span class="line">util.isDate(&#123;&#125;);<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="util-isError"><a href="#util-isError" class="headerlink" title="util.isError"></a>util.isError</h4><p><code>util.isError(object)</code>// 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">util.isError(<span class="keyword">new</span> <span class="built_in">Error</span>());<span class="comment">// true</span></span><br><span class="line">util.isError(<span class="keyword">new</span> <span class="built_in">TypeError</span>());<span class="comment">// true</span></span><br><span class="line">util.isError(&#123; name: <span class="string">'Error'</span>, message: <span class="string">'an error occurred'</span> &#125;);<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="11、Node-js-文件系统"><a href="#11、Node-js-文件系统" class="headerlink" title="11、Node.js 文件系统"></a>11、Node.js 文件系统</h3><p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">//读取文件内容</span></span><br><span class="line">fs.readFile(filename, [options], callback)<span class="comment">//异步读取文件内容。</span></span><br><span class="line">fs.readFileSync(filename, [options])<span class="comment">//同步读取文件内容。</span></span><br></pre></td></tr></table></figure></p>
<p>建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p><code>fs.open(path, flags, [mode], callback)</code>//异步打开文件。<br>    path-文件路径；flag-文件打开行为；mode-设置文件模式(默认:0666-可读可写)；callback - 回调函数，带有两个参数如：callback(err, fd)。<br>flags参数描述：<br>1  <code>r</code> //以读取模式打开文件。如果文件不存在抛出异常。<br>2  <code>r+</code> //以读写模式打开文件。如果文件不存在抛出异常。<br>3  <code>rs</code> //以同步的方式读取文件。<br>4  <code>rs+</code> //以同步的方式读取和写入文件。<br>5  <code>w</code> //以写入模式打开文件，如果文件不存在则创建。<br>6  <code>wx</code> //类似 ‘w’，但是如果文件路径存在，则文件写入失败。<br>7  <code>w+</code> //以读写模式打开文件，如果文件不存在则创建。<br>8  <code>wx+</code> //类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。<br>9  <code>a</code> //以追加模式打开文件，如果文件不存在则创建。<br>10  <code>ax</code> //类似 ‘a’， 但是如果文件路径存在，则文件追加失败。<br>11  <code>a+</code> //以读取追加模式打开文件，如果文件不存在则创建。<br>12  <code>ax+</code> //类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</p>
<h4 id="读取文件信息"><a href="#读取文件信息" class="headerlink" title="读取文件信息"></a>读取文件信息</h4><p><code>fs.stat(path, callback)</code>//通过异步模式获取文件信息.<br>    path - 文件路径。callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。<br>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。<br>stats类中方法有：<br>1  <code>stats.isFile()</code>//如果是文件返回 true，否则返回 false。<br>2  <code>stats.isDirectory()</code>//如果是目录返回 true，否则返回 false。<br>3  <code>stats.isBlockDevice()</code>//如果是块设备返回 true，否则返回 false。<br>4  <code>stats.isCharacterDevice()</code>//如果是字符设备返回 true，否则返回 false。<br>5  <code>stats.isSymbolicLink()</code>//如果是软链接返回 true，否则返回 false。<br>6  <code>stats.isFIFO()</code>//如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。<br>7  <code>stats.isSocket()</code>//如果是 Socket 返回 true，否则返回 false。</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p><code>fs.writeFile(filename, data, [options], callback)</code>//异步写入文件<br>    path-文件路径；data-要写入的数据，可以是String或Buffer(流)对象；options-该参数是一个对象，包含{encoding,mode,flag}默认utf8 ,0666,’w’；callback-回调函数，只包含错误信息参数(err),在写入失败是返回。</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p><code>fs.read(fd, buffer, offset, length, position, callback)</code>//异步模式下使用文件描述符来读取文件。<br>    fd-通过fs.open()方法返回文件描述符；buffer-数据写入的缓冲区；offset-缓冲区写入的写入偏移量；length-要从文件中读取的字节数；position-文件读取的起始位置，值为null则会从当前文件指针位置读取；callback-回调函数，有三个参数err错误信息,bytesRead字节数,buffer缓冲区对象.</p>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p><code>fs.close(fd, callback)</code>//异步模式下关闭文件,该方法使用了文件描述符来读取文件。<br>    fd - 通过 fs.open() 方法返回的文件描述符; callback - 回调函数，没有参数。</p>
<h4 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h4><p><code>fs.ftruncate(fd, len, callback)</code>//异步模式下截取文件,该方法使用了文件描述符来读取文件。<br>    fd - 通过 fs.open() 方法返回的文件描述符; len - 文件内容截取的长度; callback - 回调函数，没有参数。</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p><code>fs.unlink(path, callback)</code><br>    path - 文件路径; callback - 回调函数，没有参数。</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p><code>fs.mkdir(path[, mode], callback)</code><br>    path - 文件路径; mode - 设置目录权限，默认为 0777; callback - 回调函数，没有参数。</p>
<h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p><code>fs.readdir(path, callback)</code><br>    path - 文件路径; callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</p>
<h4 id="文件模块方法参考手册"><a href="#文件模块方法参考手册" class="headerlink" title="文件模块方法参考手册"></a>文件模块方法参考手册</h4><p>1  <code>fs.rename(oldPath, newPath, callback)</code>//异步 rename().回调函数没有参数，但可能抛出异常。<br>2  <code>fs.ftruncate(fd, len, callback)</code>//异步 ftruncate().回调函数没有参数，但可能抛出异常。<br>3  <code>fs.ftruncateSync(fd, len)</code>//同步 ftruncate()<br>4  <code>fs.truncate(path, len, callback)</code>//异步 truncate().回调函数没有参数，但可能抛出异常。<br>5  <code>fs.truncateSync(path, len)</code>//同步 truncate()<br>6  <code>fs.chown(path, uid, gid, callback)</code>//异步 chown().回调函数没有参数，但可能抛出异常。<br>7  <code>fs.chownSync(path, uid, gid)</code>//同步 chown()<br>8  <code>fs.fchown(fd, uid, gid, callback)</code>//异步 fchown().回调函数没有参数，但可能抛出异常。<br>9  <code>fs.fchownSync(fd, uid, gid)</code>//同步 fchown()<br>10  <code>fs.lchown(path, uid, gid, callback)</code>//异步 lchown().回调函数没有参数，但可能抛出异常。<br>11  <code>fs.lchownSync(path, uid, gid)</code>//同步 lchown()<br>12  <code>fs.chmod(path, mode, callback)</code>//异步 chmod().回调函数没有参数，但可能抛出异常。<br>13  <code>fs.chmodSync(path, mode)</code>//同步 chmod().<br>14  <code>fs.fchmod(fd, mode, callback)</code>//异步 fchmod().回调函数没有参数，但可能抛出异常。<br>15  <code>fs.fchmodSync(fd, mode)</code>//同步 fchmod().<br>16  <code>fs.lchmod(path, mode, callback)</code>//异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.<br>17  <code>fs.lchmodSync(path, mode)</code>//同步 lchmod().<br>18  <code>fs.stat(path, callback)</code>//异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。<br>19  <code>fs.lstat(path, callback)</code>//异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。<br>20  <code>fs.fstat(fd, callback)</code>//异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。<br>21  <code>fs.statSync(path)</code>//同步 stat(). 返回 fs.Stats 的实例。<br>22  <code>fs.lstatSync(path)</code>//同步 lstat(). 返回 fs.Stats 的实例。<br>23  <code>fs.fstatSync(fd)</code>//同步 fstat(). 返回 fs.Stats 的实例。<br>24  <code>fs.link(srcpath, dstpath, callback)</code>//异步 link().回调函数没有参数，但可能抛出异常。<br>25  <code>fs.linkSync(srcpath, dstpath)</code>//同步 link().<br>26  <code>fs.symlink(srcpath, dstpath[, type], callback)</code>//异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。<br>27  <code>fs.symlinkSync(srcpath, dstpath[, type])</code>//同步 symlink().<br>28  <code>fs.readlink(path, callback)</code>//异步 readlink(). 回调函数有两个参数 err, linkString。<br>29  <code>fs.realpath(path[, cache], callback)</code>//异步 realpath(). 回调函数有两个参数 err, resolvedPath。<br>30  <code>fs.realpathSync(path[, cache])</code>//同步 realpath()。返回绝对路径。<br>31  <code>fs.unlink(path, callback)</code>//异步 unlink().回调函数没有参数，但可能抛出异常。<br>32  <code>fs.unlinkSync(path)</code>//同步 unlink().<br>33  <code>fs.rmdir(path, callback)</code>//异步 rmdir().回调函数没有参数，但可能抛出异常。<br>34  <code>fs.rmdirSync(path)</code>//同步 rmdir().<br>35  <code>fs.mkdir(path[, mode], callback)</code>//S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 mode defaults to 0777.<br>36  <code>fs.mkdirSync(path[, mode])</code>//同步 mkdir().<br>37  <code>fs.readdir(path, callback)</code>//异步 readdir(3). 读取目录的内容。<br>38  <code>fs.readdirSync(path)</code>//同步 readdir().返回文件数组列表。<br>39  <code>fs.close(fd, callback)</code>//异步 close().回调函数没有参数，但可能抛出异常。<br>40  <code>fs.closeSync(fd)</code>//同步 close().<br>41  <code>fs.open(path, flags[, mode], callback)</code>//异步打开文件。<br>42  <code>fs.openSync(path, flags[, mode])</code>//同步 version of fs.open().<br>43  <code>fs.utimes(path, atime, mtime, callback)
44</code>fs.utimesSync(path, atime, mtime)<code>//修改文件时间戳，文件通过指定的文件路径。
45</code>fs.futimes(fd, atime, mtime, callback)<br>46  <code>fs.futimesSync(fd, atime, mtime)</code>//修改文件时间戳，通过文件描述符指定。<br>47  <code>fs.fsync(fd, callback)</code>//异步 fsync.回调函数没有参数，但可能抛出异常。<br>48  <code>fs.fsyncSync(fd)</code>//同步 fsync.<br>49  <code>fs.write(fd, buffer, offset, length[, position], callback)</code>//将缓冲区内容写入到通过文件描述符指定的文件。<br>50  <code>fs.write(fd, data[, position[, encoding]], callback)</code>//通过文件描述符 fd 写入文件内容。<br>51  <code>fs.writeSync(fd, buffer, offset, length[, position])</code>//同步版的 fs.write()。<br>52  <code>fs.writeSync(fd, data[, position[, encoding]])</code>//同步版的 fs.write().<br>53  <code>fs.read(fd, buffer, offset, length, position, callback)</code>//通过文件描述符 fd 读取文件内容。<br>54  <code>fs.readSync(fd, buffer, offset, length, position)</code>//同步版的 fs.read.<br>55  <code>fs.readFile(filename[, options], callback)</code>//异步读取文件内容。<br>56  <code>fs.readFileSync(filename[, options])
57</code>fs.writeFile(filename, data[, options], callback)<br>异步写入<code>文件内容。
58</code>fs.writeFileSync(filename, data[, options])<code>//同步版的 fs.writeFile。
59</code>fs.appendFile(filename, data[, options], callback)<code>//异步追加文件内容。
60</code>fs.appendFileSync(filename, data[, options])<code>//The 同步 version of fs.appendFile.
61</code>fs.watchFile(filename[, options], listener)<code>//查看文件的修改。
62</code>fs.unwatchFile(filename[, listener])<code>//停止查看 filename 的修改。
63</code>fs.watch(filename[, options][, listener])<code>//查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。
64</code>fs.exists(path, callback)<code>//检测给定的路径是否存在。
65</code>fs.existsSync(path)<code>//同步版的 fs.exists.
66</code>fs.access(path[, mode], callback)<code>//测试指定路径用户权限。
67</code>fs.accessSync(path[, mode])<code>//同步版的 fs.access。
68</code>fs.createReadStream(path[, options])<code>//返回ReadStream 对象。
69</code>fs.createWriteStream(path[, options])<code>//返回 WriteStream 对象。
70</code>fs.symlink(srcpath, dstpath[, type], callback)`//异步 symlink().回调函数没有参数，但可能抛出异常。</p>
<h3 id="12、Node-js-GET-POST请求"><a href="#12、Node-js-GET-POST请求" class="headerlink" title="12、Node.js GET/POST请求"></a>12、Node.js GET/POST请求</h3><h4 id="获取GET请求内容"><a href="#获取GET请求内容" class="headerlink" title="获取GET请求内容"></a>获取GET请求内容</h4><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中访问<code>http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc</code> 然后查看返回结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="literal">null</span>,</span><br><span class="line">  slashes: <span class="literal">null</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="literal">null</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="literal">null</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="string">'?name=w3c&amp;email=w3c@w3cschool.cc'</span>,</span><br><span class="line">  query: &#123; name: <span class="string">'w3c'</span>, email: <span class="string">'w3c@w3cschool.cc'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/user'</span>,</span><br><span class="line">  path: <span class="string">'/user?name=w3c&amp;email=w3c@w3cschool.cc'</span>,</span><br><span class="line">  href: <span class="string">'/user?name=w3c&amp;email=w3c@w3cschool.cc'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="获取POST请求内容"><a href="#获取POST请求内容" class="headerlink" title="获取POST请求内容"></a>获取POST请求内容</h4><p>POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的， 当你需要的时候，需要手动来做。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> post = <span class="string">''</span>;<span class="comment">//定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line">  req.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;<span class="comment">//通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">    post += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    post = querystring.parse(post);</span><br><span class="line">    res.end(util.inspect(post));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="13、Node-js-工具模块"><a href="#13、Node-js-工具模块" class="headerlink" title="13、Node.js 工具模块"></a>13、Node.js 工具模块</h3><h4 id="Node-js-OS-模块"><a href="#Node-js-OS-模块" class="headerlink" title="Node.js OS 模块"></a>Node.js OS 模块</h4><p>Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>os.tmpdir()</code>//返回操作系统的默认临时文件夹。<br>2  <code>os.endianness()</code>//返回 CPU 的字节序，可能的是 “BE” 或 “LE”。<br>3  <code>os.hostname()</code>//返回操作系统的主机名。<br>4  <code>os.type()</code>//返回操作系统名<br>5  <code>os.platform()</code>//返回操作系统名<br>6  <code>os.arch()</code>//返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。<br>7  <code>os.release()</code>//返回操作系统的发行版本。<br>8  <code>os.uptime()</code>//返回操作系统运行的时间，以秒为单位。<br>9  <code>os.loadavg()</code>//返回一个包含 1、5、15 分钟平均负载的数组。<br>10  <code>os.totalmem()</code>//返回系统内存总量，单位为字节。<br>11  <code>os.freemem()</code>//返回操作系统空闲内存量，单位是字节。<br>12  <code>os.cpus()</code>//返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。<br>13  <code>os.networkInterfaces()</code>//获得网络接口列表。</p>
<h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h5><p><code>os.EOL</code>//定义了操作系统的行尾符的常量。<br>实例<br>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'endianness : '</span> + os.endianness());<span class="comment">// CPU 的字节序</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'type : '</span> + os.type());<span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'platform : '</span> + os.platform());<span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'total memory : '</span> + os.totalmem() + <span class="string">" bytes."</span>);<span class="comment">// 系统内存总量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'free memory : '</span> + os.freemem() + <span class="string">" bytes."</span>);<span class="comment">// 操作系统空闲内存量</span></span><br></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node main.js </span><br><span class="line">endianness : LE</span><br><span class="line">type : Linux</span><br><span class="line">platform : linux</span><br><span class="line">total memory : 25103400960 bytes.</span><br><span class="line">free memory : 20676710400 bytes.</span><br></pre></td></tr></table></figure></p>
<h4 id="Node-js-Path-模块"><a href="#Node-js-Path-模块" class="headerlink" title="Node.js Path 模块"></a>Node.js Path 模块</h4><p>Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>1  <code>path.normalize(p)</code>//规范化路径，注意’..’ 和 ‘.’。<br>2  <code>path.join([path1][, path2][, ...])</code>//用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\”。<br>3  <code>path.resolve([from ...], to)</code>//将 to 参数解析为绝对路径。<br>4  <code>path.isAbsolute(path)</code>//判断参数 path 是否是绝对路径。<br>5  <code>path.relative(from, to)</code>//用于将相对路径转为绝对路径。<br>6  <code>path.dirname(p)</code>//返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。<br>7  <code>path.basename(p[, ext])</code>//返回路径中的最后一部分。同 Unix 命令 bashname 类似。<br>8  <code>path.extname(p)</code>//返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。<br>9  <code>path.parse(pathString)</code>//返回路径字符串的对象。<br>10  <code>path.format(pathObject)</code>//从对象中返回路径字符串，和 path.parse 相反。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>1  <code>path.sep</code>//平台的文件路径分隔符，’\‘ 或 ‘/‘。<br>2  <code>path.delimiter</code>//平台的分隔符, ; or ‘:’.<br>3  <code>path.posix</code>//提供上述 path 的方法，不过总是以 posix 兼容的方式交互。<br>4  <code>path.win32</code>//提供上述 path 的方法，不过总是以 win32 兼容的方式交互。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="comment">// 格式化路径</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'normalization : '</span> + path.normalize(<span class="string">'/test/test1//2slashes/1slash/tab/..'</span>));</span><br><span class="line"><span class="comment">// 连接路径</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'joint path : '</span> + path.join(<span class="string">'/test'</span>, <span class="string">'test1'</span>, <span class="string">'2slashes/1slash'</span>, <span class="string">'tab'</span>, <span class="string">'..'</span>));</span><br><span class="line"><span class="comment">// 转换为绝对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'resolve : '</span> + path.resolve(<span class="string">'main.js'</span>));</span><br><span class="line"><span class="comment">// 路径中文件的后缀名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ext name : '</span> + path.extname(<span class="string">'main.js'</span>));</span><br></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node main.js </span><br><span class="line">normalization : <span class="regexp">/test/</span>test1/<span class="number">2</span>slashes/<span class="number">1</span>slash</span><br><span class="line">joint path : <span class="regexp">/test/</span>test1/<span class="number">2</span>slashes/<span class="number">1</span>slash</span><br><span class="line">resolve : <span class="regexp">/web/</span>com/<span class="number">1427176256</span>_27423/main.js</span><br><span class="line">ext name : .js</span><br></pre></td></tr></table></figure></p>
<h4 id="Node-js-Net-模块"><a href="#Node-js-Net-模块" class="headerlink" title="Node.js Net 模块"></a>Node.js Net 模块</h4><p>Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>net.createServer([options][, connectionListener])</code>//创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。<br>2  <code>net.connect(options[, connectionListener])</code>//返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。当 socket 建立的时候，将会触发 ‘connect’ 事件。<br>3  <code>net.createConnection(options[, connectionListener])</code>//创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。<br>4  <code>net.connect(port[, host][, connectListener])</code>//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>5  <code>net.createConnection(port[, host][, connectListener])</code>//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>6  <code>net.connect(path[, connectListener])</code>//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。<br>7  <code>net.createConnection(path[, connectListener])</code>//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>8  <code>net.isIP(input)</code>//检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。<br>9  <code>net.isIPv4(input)</code>//如果输入的地址为 IPV4， 返回 true，否则返回 false。<br>10  <code>net.isIPv6(input)</code>//如果输入的地址为 IPV6， 返回 true，否则返回 false。</p>
<h4 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h4><p>net.Server通常用于创建一个 TCP 或本地服务器。</p>
<h5 id="net-Server方法："><a href="#net-Server方法：" class="headerlink" title="net.Server方法："></a>net.Server方法：</h5><p>1  <code>server.listen(port[, host][, backlog][, callback])</code>//监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。<br>2  <code>server.listen(path[, callback])</code>//通过指定 path 的连接，启动一个本地 socket 服务器。<br>3  <code>server.listen(handle[, callback])</code>//通过指定句柄连接。<br>4  <code>server.listen(options[, callback])</code>//options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。<br>5  <code>server.close([callback])</code>//服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。<br>6  <code>server.address()</code>//操作系统返回绑定的地址，协议族名和服务器端口。<br>7  <code>server.unref()</code>//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。<br>8  <code>server.ref()</code>//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。<br>9  <code>server.getConnections(callback)</code>//异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</p>
<h5 id="net-Server事件："><a href="#net-Server事件：" class="headerlink" title="net.Server事件："></a>net.Server事件：</h5><p>1  <code>listening</code>//当服务器调用 server.listen 绑定后会触发。<br>2  <code>connection</code>//当新连接创建后会被触发。socket 是 net.Socket实例。<br>3  <code>close</code>//服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。<br>4  <code>error</code>//发生错误时触发。’close’ 事件将被下列事件直接调用。</p>
<h4 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h4><p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。</p>
<h5 id="net-Socket事件："><a href="#net-Socket事件：" class="headerlink" title="net.Socket事件："></a>net.Socket事件：</h5><p>1  <code>lookup</code>//在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。<br>2  <code>connect</code>//成功建立 socket 连接时触发。<br>3  <code>data</code>//当接收到数据时触发。<br>4  <code>end</code>//当 socket 另一端发送 FIN 包时，触发该事件。<br>5  <code>timeout</code>//当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。<br>6  <code>drain</code>//当写缓存为空得时候触发。可用来控制上传。<br>7  <code>error</code>//错误发生时触发。<br>8  <code>close</code>//当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。</p>
<h5 id="net-Socket属性："><a href="#net-Socket属性：" class="headerlink" title="net.Socket属性："></a>net.Socket属性：</h5><p>1  <code>socket.bufferSize</code>//该属性显示了要写入缓冲区的字节数。<br>2  <code>socket.remoteAddress</code>//远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。<br>3  <code>socket.remoteFamily</code>//远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。<br>4  <code>socket.remotePort</code>//远程端口，数字表示，例如：80 or 21。<br>5  <code>socket.localAddress</code>//网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。<br>6  <code>socket.localPort</code>//本地端口地址，数字表示。例如：80 or 21。<br>7  <code>socket.bytesRead</code>//接收到得字节数。<br>8  <code>socket.bytesWritten</code>//发送的字节数。</p>
<h5 id="net-Socket方法："><a href="#net-Socket方法：" class="headerlink" title="net.Socket方法："></a>net.Socket方法：</h5><p>1  <code>new net.Socket([options])</code>//构造一个新的 socket 对象。<br>2  <code>socket.connect(port[, host][, connectListener])</code>//指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。<br>3  <code>socket.connect(path[, connectListener])</code>//打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。<br>4  <code>socket.setEncoding([encoding])</code>//设置编码<br>5  <code>socket.write(data[, encoding][, callback])</code>//在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。<br>6  <code>socket.end([data][, encoding])</code>//半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。<br>7  <code>socket.destroy()</code>//确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。<br>8  <code>socket.pause()</code>//暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。<br>9  <code>socket.resume()</code>//调用 pause() 后想恢复读取数据。<br>10  <code>socket.setTimeout(timeout[, callback])</code>//socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。<br>11  <code>socket.setNoDelay([noDelay])</code>//禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。<br>12  <code>socket.setKeepAlive([enable][, initialDelay])</code>//禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.<br>13  <code>socket.address()</code>//操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。<br>14  <code>socket.unref()</code>//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。<br>15  <code>socket.ref()</code>//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</p>
<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>创建 server.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">connection</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">  connection.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'客户端关闭连接'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  connection.write(<span class="string">'Hello World!\r\n'</span>);</span><br><span class="line">  connection.pipe(connection);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is listening'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行以上服务端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br><span class="line">server is listening # 服务已创建并监听8080端口</span><br></pre></td></tr></table></figure></p>
<p>新开一个窗口，创建client.js文件，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123;port: <span class="number">8080</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'连接服务器！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'断开与服务器的连接'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行以上客户端的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接服务器！</span><br><span class="line">Hello World!</span><br><span class="line">断开与服务器的连接</span><br></pre></td></tr></table></figure></p>
<h4 id="Node-js-DNS-模块"><a href="#Node-js-DNS-模块" class="headerlink" title="Node.js DNS 模块"></a>Node.js DNS 模块</h4><pre><code>  //Node.js DNS 模块用于解析域名。引入 DNS 模块语法格式如下：
  var dns = require(&quot;dns&quot;)
  //方法：
    1 dns.lookup(hostname[, options], callback)//将域名（比如 &apos;runoob.com&apos;）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。
    2 dns.lookupService(address, port, callback)//使用 getnameinfo 解析传入的地址和端口为域名和服务。
    3 dns.resolve(hostname[, rrtype], callback)//将一个域名（如 &apos;runoob.com&apos;）解析为一个 rrtype 指定记录类型的数组。
    4 dns.resolve4(hostname, callback)//和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]）。
    5 dns.resolve6(hostname, callback)//和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）
    6 dns.resolveMx(hostname, callback)//和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。
    7 dns.resolveTxt(hostname, callback)//和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [&apos;v=spf1 ip4:0.0.0.0 &apos;, &apos;~all&apos; ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。
    8 dns.resolveSrv(hostname, callback)//和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{&apos;priority&apos;: 10, &apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]）。
    9 dns.resolveSoa(hostname, callback)//和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。
    10  dns.resolveNs(hostname, callback)//和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]）。
    11  dns.resolveCname(hostname, callback)//和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [&apos;bar.example.com&apos;]）。
    12  dns.reverse(ip, callback)//反向解析 IP 地址，指向该 IP 地址的域名数组。
    13  dns.getServers()//返回一个用于当前解析的 IP 地址数组的字符串。
    14  dns.setServers(servers)//指定一组 IP 地址作为解析服务器。
  //rrtypes
    //dns.resolve()方法中有效的rrtypes值：          
        &apos;A&apos; IPV4 地址, 默认
        &apos;AAAA&apos; IPV6 地址
        &apos;MX&apos; 邮件交换记录
        &apos;TXT&apos; text 记录
        &apos;SRV&apos; SRV 记录
        &apos;PTR&apos; 用来反向 IP 查找
        &apos;NS&apos; 域名服务器记录
        &apos;CNAME&apos; 别名记录
        &apos;SOA&apos; 授权记录的初始值
  //错误码
    //每次 DNS 查询都可能返回以下错误码：          
        dns.NODATA: 无数据响应。
        dns.FORMERR: 查询格式错误。
        dns.SERVFAIL: 常规失败。
        dns.NOTFOUND: 没有找到域名。
        dns.NOTIMP: 未实现请求的操作。
        dns.REFUSED: 拒绝查询。
        dns.BADQUERY: 查询格式错误。
        dns.BADNAME: 域名格式错误。
        dns.BADFAMILY: 地址协议不支持。
        dns.BADRESP: 回复格式错误。
        dns.CONNREFUSED: 无法连接到 DNS 服务器。
        dns.TIMEOUT: 连接 DNS 服务器超时。
        dns.EOF: 文件末端。
        dns.FILE: 读文件错误。
        dns.NOMEM: 内存溢出。
        dns.DESTRUCTION: 通道被摧毁。
        dns.BADSTR: 字符串格式错误。
        dns.BADFLAGS: 非法标识符。
        dns.NONAME: 所给主机不是数字。
        dns.BADHINTS: 非法HINTS标识符。
        dns.NOTINITIALIZED: c c-ares 库尚未初始化。
        dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。
        dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。
        dns.CANCELLED: 取消 DNS 查询。
  //实例
    //创建 main.js 文件，代码如下所示：
      var dns = require(&apos;dns&apos;);
      dns.lookup(&apos;www.github.com&apos;,function onLookup(err, address, family){
        console.log(&apos;ip 地址：&apos;, address);
        dns.reverse(address, function(err, hostname){
          if (err) {
            console.log(err.stack);
          }
          console.log(&apos;反向解析&apos; + address + &apos;:&apos; + JSON.stringify(hostname));
        });
      });
    //执行以上代码，结果如下所示：
      address: 192.30.252.130
      reverse for 192.30.252.130: [&quot;github.com&quot;]
/*Node.js Domain 模块*/
  //Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：
  var domain = require(&quot;domain&quot;)
  //domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(&apos;uncaughtException&apos;)不同。
  //Domain 模块可分为隐式绑定和显式绑定：
    //隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象
    //显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象
  //方法：
    1 domain.run(function)//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。
    2 domain.add(emitter)//显式的增加事件
    3 domain.remove(emitter)//删除事件。
    4 domain.bind(callback)//返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。
    5 domain.intercept(callback)//和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。
    6 domain.enter()//进入一个异步调用的上下文，绑定到domain。
    7 domain.exit()//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。
    8 domain.dispose()//释放一个domain对象，让node进程回收这部分资源。
    9 domain.create()//返回一个domain对象。
  //事件：
    domain.menbers//已加入domain对象的域定时器和事件发射器的数组。
  //实例
    //创建 main.js 文件，代码如下所示：
      var EventEmitter = require(&quot;events&quot;).EventEmitter;
      var domain = require(&quot;domain&quot;);
      var emitter1 = new EventEmitter();
      // 创建域
      var domain1 = domain.create();
      domain1.on(&apos;error&apos;, function(err){
         console.log(&quot;domain1 处理这个错误 (&quot;+err.message+&quot;)&quot;);
      });
      // 显式绑定
      domain1.add(emitter1);
      emitter1.on(&apos;error&apos;,function(err){
         console.log(&quot;监听器处理此错误 (&quot;+err.message+&quot;)&quot;);
      });
      emitter1.emit(&apos;error&apos;,new Error(&apos;通过监听器来处理&apos;));
      emitter1.removeAllListeners(&apos;error&apos;);
      emitter1.emit(&apos;error&apos;,new Error(&apos;通过 domain1 处理&apos;));
      var domain2 = domain.create();
      domain2.on(&apos;error&apos;, function(err){
         console.log(&quot;domain2 处理这个错误 (&quot;+err.message+&quot;)&quot;);
      });
      // 隐式绑定
      domain2.run(function(){
         var emitter2 = new EventEmitter();
         emitter2.emit(&apos;error&apos;,new Error(&apos;通过 domain2 处理&apos;));   
      });
      domain1.remove(emitter1);
      emitter1.emit(&apos;error&apos;, new Error(&apos;转换为异常，系统将崩溃!&apos;));
    //执行以上代码，结果如下所示:
      监听器处理此错误 (通过监听器来处理)
      domain1 处理这个错误 (通过 domain1 处理)
      domain2 处理这个错误 (通过 domain2 处理)
      events.js:72
              throw er; // Unhandled &apos;error&apos; event
                    ^
      Error: 转换为异常，系统将崩溃!
          at Object.&lt;anonymous&gt; (/www/node/main.js:40:24)
          at Module._compile (module.js:456:26)
          at Object.Module._extensions..js (module.js:474:10)
          at Module.load (module.js:356:32)
          at Function.Module._load (module.js:312:12)
          at Function.Module.runMain (module.js:497:10)
          at startup (node.js:119:16)
          at node.js:929:3
</code></pre><p>/14、Node.js Web 模块 <em>/<br>    /</em>使用 Node 创建 Web 服务器<em>/<br>      //Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：<br>      var http = require(‘http’);<br>      //以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示：<br>        var http = require(‘http’);<br>        var fs = require(‘fs’);<br>        var url = require(‘url’);<br>        //创建服务器<br>        http.createServer(function(request,response){<br>          //解析请求，包括文件名<br>          var pathname = url.parse(request.url).pathname;<br>          //输出请求文件名<br>          console.log(“Request for “ + pathname + “ received.”);<br>          //从文件系统中读取请求的文件内容<br>          fs.readFile(pathname.substr(1), function (err, data){<br>            if (err) {<br>              console.log(err);<br>              //HTTP 状态码：404：NOT FOUND<br>              //Content Type：text/plain<br>              response.writeHead(404, {‘Content-Type’: ‘text/html’});<br>            } else{<br>              //HTTP 状态码：200：OK<br>              //Content Type：text/plain<br>              response.writeHead(200, {‘Content-Type’: ‘text/html’});<br>              //响应文件内容<br>              response.write(data.toString());<br>            };<br>            //发送响应数据<br>            response.end();<br>          });<br>        }).listen(8081);<br>        //控制台会输出以下信息<br>        console.log(‘Server running at <a href="http://127.0.0.1:8081/" target="_blank" rel="external">http://127.0.0.1:8081/</a>‘);<br>      //接下来我们在该目录下创建一个 index.htm 文件，代码如下：<br>        <html><br>        <head><br>        <title>Sample Page</title><br>        </head><br>        <body><br>            Hello World!<br>        </body><br>        </html><br>      //执行 server.js 文件：<br>        node server.js<br>        Server running at <a href="http://127.0.0.1:8081/" target="_blank" rel="external">http://127.0.0.1:8081/</a><br>    /</em>使用 Node 创建 Web 客户端*/<br>      //Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：<br>        <pre><br>        var http = require(‘http’);<br>        //用于请求选项<br>        var optionss = {<br>          host:’localhost’,<br>          port:’8081’<br>          path:’/index.htm’<br>        };<br>        //处理响应的回调函数<br>        var callback = function(response){<br>          //不断更新数据<br>          var body = ‘’;<br>          response.on(‘data’, function(data){<br>            body += data;<br>          });<br>          response.on(‘end’, function(){<br>            //数据接收完成<br>            console.log(body);<br>          });<br>        }<br>        //向服务器端发送请求<br>        var req = http.request(options, callback);<br>        req.end();<br>      //新开一个终端，执行 client.js 文件，输出结果如下：<br>        node client.js<br>        <html><br>        <head><br>        <title>Sample Page</title><br>        </head><br>        <body><br>        Hello World!<br>        </body><br>        </html><br>      //执行 server.js 的控制台输出信息如下：<br>        Server running at <a href="http://127.0.0.1:8081/" target="_blank" rel="external">http://127.0.0.1:8081/</a><br>        Request for /index.htm received.   # 客户端请求信息</pre></p>
<p>/15、Node.js Express 框架 <em>/<br>    //Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。<br>    //Express 框架核心特性：1、可以设置中间件来响应 HTTP 请求。2、定义了路由表用于执行不同的 HTTP 请求动作。3、可以通过向模板传递参数来动态渲染 HTML 页面。<br>    /</em>安装 Express<em>/<br>      //安装 Express 并将其保存到依赖列表中：<br>        npm install express –save<br>      //以上命令会将 Express 框架安装在当期目录的 node_modules 目录中， node_modules 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：<br>        //body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。<br>        //cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。<br>        //multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。<br>          npm install body-parser –save<br>          npm install cookie-parser –save<br>          npm install multer –save<br>    /</em>第一个 Express 框架实例<em>/<br>      //接下来我们使用 Express 框架来输出 “Hello World”。以下实例中我们引入了 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。<br>      //创建 express_demo.js 文件，代码如下所示：<br>        var express = require(‘express’);<br>        var app = express();<br>        app.get(‘/‘, function (req,res){<br>          res.send(‘Hello World’);<br>        });<br>        var server = app.listen(8081, function(){<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        });<br>      //执行以上代码：<br>        node express_demo.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //在浏览器中访问 <a href="http://127.0.0.1:8081，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081，结果如下所示：</a><br>        Hello World<br>    /</em>请求和响应<em>/<br>      //Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。<br>        /</em>Request 对象<em>/<br>          //request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：<br>              req.app：当callback为外部文件时，用req.app访问express的实例<br>              req.baseUrl：获取路由当前安装的URL路径<br>              req.body / req.cookies：获得「请求主体」/ Cookies<br>              req.fresh / req.stale：判断请求是否还「新鲜」<br>              req.hostname / req.ip：获取主机名和IP地址<br>              req.originalUrl：获取原始请求URL<br>              req.params：获取路由的parameters<br>              req.path：获取请求路径<br>              req.protocol：获取协议类型<br>              req.query：获取URL的查询参数串<br>              req.route：获取当前匹配的路由<br>              req.subdomains：获取子域名<br>              req.accpets（）：检查请求的Accept头的请求类型<br>              req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages<br>              req.get（）：获取指定的HTTP请求头<br>              req.is（）：判断请求头Content-Type的MIME类型<br>        /</em>Response 对象<em>/<br>          // response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：<br>              res.app：同req.app一样<br>              res.append（）：追加指定HTTP头<br>              res.set（）在res.append（）后将重置之前设置的头<br>              res.cookie（name，value [，option]）：设置Cookie<br>              opition: domain / expires / httpOnly / maxAge / path / secure / signed<br>              res.clearCookie（）：清除Cookie<br>              res.download（）：传送指定路径的文件<br>              res.get（）：返回指定的HTTP头<br>              res.json（）：传送JSON响应<br>              res.jsonp（）：传送JSONP响应<br>              res.location（）：只设置响应的Location HTTP头，不设置状态码或者close response<br>              res.redirect（）：设置响应的Location HTTP头，并且设置状态码302<br>              res.send（）：传送HTTP响应<br>              res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Type<br>              res.set（）：设置HTTP头，传入object可以一次设置多个头<br>              res.status（）：设置HTTP状态码<br>              res.type（）：设置Content-Type的MIME类型<br>    /</em>路由<em>/<br>      // 我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。接下来我们扩展 Hello World，添加一些功能来处理更多类型的 HTTP 请求。<br>      //创建 express_demo2.js 文件，代码如下所示：<br>        var express = require(‘express’);<br>        var app = express();<br>        //主页输出”Hello World”<br>        app.get(‘/‘, function (req, res){<br>          console.log(“主页GET请求”);<br>          res.send(‘Hello GET’);<br>        });<br>        //POST请求<br>        app.post(‘/‘, function (req, res){<br>          console.log(“主页 POST 请求”);<br>          res.send(‘Hello POST’);<br>        });<br>        // /del_user页面响应<br>        app.delete(‘/del_user’, function (req, res){<br>          console.log(“/del_user响应 DELETE 请求”);<br>          res.send(‘删除页面’);<br>        });<br>        // /list_user 页面 GET 请求<br>        app.get(‘/list_user’, function (req, res){<br>          console.log(“/list_user 页面 GET 请求”);<br>          res.send(‘用户列表页面’);<br>        });<br>        // 对页面 abcd, abxcd, ab123cd, 等响应GET请求<br>        app.get(‘/ab</em>cd’, function (req, res){<br>          console.log(“/ab<em>cd GET 请求”);<br>          res.send(‘正则匹配’)<br>        });<br>        var server = app.listen(8081,function(){<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        });<br>      //执行以上代码：<br>        node express_demo2.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //接下来你可以尝试访问 <a href="http://127.0.0.1:8081" target="_blank" rel="external">http://127.0.0.1:8081</a> 不同的地址，查看效果。<br>        访问 <a href="http://127.0.0.1:8081/list_user" target="_blank" rel="external">http://127.0.0.1:8081/list_user</a> 结果：用户列表页<br>        访问 <a href="http://127.0.0.1:8081/abcd" target="_blank" rel="external">http://127.0.0.1:8081/abcd</a> 结果：正则匹配<br>        访问 <a href="http://127.0.0.1:8081/abcdefg" target="_blank" rel="external">http://127.0.0.1:8081/abcdefg</a> 结果：Cannot GET/abcdefg 无法解析该地址<br>    /</em>静态文件<em>/<br>      //Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：<br>        app.use(express.static(‘public’));//public为放置静态文件的目录<br>      //我们可以到 public/images 目录下放些图片,如下所示：<br>        node_modules<br>        server.js<br>        public/<br>        public/images<br>        public/images/logo.png<br>      // 让我们再修改下 “Hello Word” 应用添加处理静态文件的功能。<br>      //创建 express_demo3.js 文件，代码如下所示：<br>        var express = require(‘express’);<br>        var app = express();<br>        app.use(express.static(‘public’));<br>        app.get(‘/‘, function (req, res){<br>          res.send(‘Hello World’);<br>        });<br>        var server = app.listen(8081, function(){<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        })<br>      //执行以上代码：<br>        node express_demo3.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //在浏览器中访问 <a href="http://127.0.0.1:8081/images/logo.png" target="_blank" rel="external">http://127.0.0.1:8081/images/logo.png</a> ,结果展示了图片。<br>    /</em>GET 方法<em>/<br>      // 以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：<br>      //index.htm 文件代码如下：<br>        <html><br>          <body><br>            <form action="http://127.0.0.1:8081/process_get" method="GET"><br>              First Name:<input type="text" name="first_name"><br><br>              Last Name: <input type="text" name="last_name"><br>              <input type="submit" name="Submit"><br>            </form><br>          </body><br>        </html><br>      //server.js文件：<br>        var express = require(‘express’);<br>        var app = express();<br>        app.use(express.static(‘public’));<br>        app.get(‘/index.htm’, function (req, res){<br>          res.sendFile(__dirname + “/“ + “index.htm”);<br>        });<br>        app.get(‘/process_get’, function (req, res){<br>          //输出JSON格式<br>          response = {<br>            first_name:req.query.first_name,<br>            last_name:req.query.last_name<br>          };<br>          console.log(response);<br>          res.end(JSON.stringify(response));<br>        });<br>        var server = app.listen(8081, function(){<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        });<br>      //执行以上代码：<br>        node server.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //浏览器访问 <a href="http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果：" target="_blank" rel="external">http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果：</a><br>        {“first_name”:”aaa”,”last_name”:”bbb”}<br>    /</em>POST 方法<em>/<br>      // 以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：<br>      //index.htm 文件代码修改如下：<br>        <html><br>          <body><br>            <form action="http://127.0.0.1:8081/process_post" method="POST"><br>              First Name: <input type="text" name="first_name"><br><br>              Last Name: <input type="text" name="last_name"><br>              <input type="submit" value="Submit"><br>            </form><br>          </body><br>        </html><br>      //server.js 文件代码修改如下:<br>        var express = require(‘express’);<br>        var app = express();<br>        var bodyParser = require(‘body-parser’);<br>        //创建application/x-www-form-urlencode编码解析<br>        var urlencodedParser = bodyParser.urlencoded({extended:false});<br>        app.use(express.static(‘public’));<br>        app.get(‘/index.htm’, function (req, res) {<br>          res.sendFile(__dirname + “/“ + “index.htm”);<br>        });<br>        app.post(‘/process_post’, urlencodedParser, function (req, res){<br>          //输出 JSON 格式<br>          response = {<br>            first_name:req.body.first_name,<br>            last_name:req.body.last_name<br>          };<br>          console.log(response);<br>          res.end(JSON.stringify(response));<br>        });<br>        var server = app.listen(8081, function(){<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        });<br>      //执行以上代码：<br>        node server.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //浏览器访问 <a href="http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果：" target="_blank" rel="external">http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果：</a><br>        {“first_name”:”aaa”,”last_name”:”bbb”}<br>    /</em>文件上传<em>/<br>      //以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。<br>      //index.htm 文件代码修改如下：<br>        <html><br>          <head><br>            <title>文件上传表单</title><br>          </head><br>          <body><br>            <h3>文件上传：</h3><br>            选择一个文件上传: <br><br>            <form action="/file_upload" method="post" enctype="multipart/form-data"><br>              <input type="file" name="image" size="50"><br><br>              <input type="submit" value="上传文件"><br>            </form><br>          </body><br>        </html><br>      //server.js 文件代码修改如下:<br>        var express = require(‘express’);<br>        var app = express();<br>        var fs = require(“fs”);<br>        var bodyParser = require(‘body-parser’);<br>        var multer = require(‘multer’);<br>        app.use(express.static(‘public’));<br>        app.use(bodyParser.urlencoded({extended:false}));<br>        app.use(multer({dest:’/tmp/‘}).array(‘image’));<br>        app.get(‘/index.htm’, function (req, res) {<br>          res.sendFile(<strong>dirname + “/“ + “index.htm”);<br>        });<br>        app.post(‘/file_upload’, function (req, res) {<br>          console.log(req.files[0]);//上传文件信息<br>          var des_file = </strong>dirname + “/“ + req.files[0].originalname;<br>          fs.readFile(req. files[0].path, function (err, data) {<br>            fs.writeFile(des_file, data, function (err) {<br>              if (err) {<br>                console.log(err);<br>              } else{<br>                response = {<br>                  message:’File uploaded successfully’,<br>                  filename:req.files[0].originalname<br>                };<br>              };<br>              console.log(response);<br>              res.end(JSON.stringify(response));<br>            });<br>          });<br>        });<br>        var server = app.listen(8081,function() {<br>          var host = server.address().address;<br>          var port = server.address().port;<br>          console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port);<br>        });<br>      //执行以上代码：<br>        node server.js<br>        应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>      //浏览器访问 <a href="http://127.0.0.1:8081/index.htm,上传本地文件a.jpg，结果：" target="_blank" rel="external">http://127.0.0.1:8081/index.htm,上传本地文件a.jpg，结果：</a><br>        {“message”:”File uploaded successfully”,”filename”:”a.jpg”}<br>    /</em>Cookie 管理*/<br>      //我们可以使用中间件向 Node.js 服务器发送 cookie 信息，以下代码输出了客户端发送的 cookie 信息：<br>      // express_cookie.js文件<br>        var express = require(‘express’);<br>        var cookieParser = require(‘cookie-parser’);<br>        var app = express();<br>        app.use(cookieParser());<br>        app.get(‘/‘, function (req, res) {<br>          console.log(“Cookies: “, req.cookies);<br>        });<br>        app.listen(8081);</p>
<p>/16、Node.js RESTful API <em>/<br>    //REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。<br>    /</em>HTTP 方法<em>/<br>      //以下为 REST 基本架构的四个方法：<br>        GET - 用于获取数据。<br>        PUT - 用于添加数据。<br>        DELETE - 用于删除数据。<br>        POST - 用于更新或添加数据。<br>    /</em>创建 RESTful<em>/<br>      //首先，创建一个 json 数据资源文件 users.json，内容如下：<br>        {<br>           “user1” : {<br>              “name” : “mahesh”,<br>            “password” : “password1”,<br>            “profession” : “teacher”,<br>            “id”: 1<br>           },<br>           “user2” : {<br>              “name” : “suresh”,<br>            “password” : “password2”,<br>            “profession” : “librarian”,<br>            “id”: 2<br>           },<br>           “user3” : {<br>              “name” : “ramesh”,<br>            “password” : “password3”,<br>            “profession” : “clerk”,<br>            “id”: 3<br>           }<br>        }<br>      //基于以上数据，我们创建以下 RESTful API：<br>        序号  URI       HTTP方法  发送内容   结果<br>          1   listUsers   GET     空          显示所有用户列表<br>          2   addUser   POST      JSON 字符串   添加新用户<br>          3   deleteUser  DELETE    JSON 字符串   删除用户<br>          4   :id       GET     空          显示用户详细信息<br>      /</em>获取用户列表：listUsers<em>/<br>        //创建 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：<br>          var express = require(‘express’);<br>          var app = express();<br>          var fs = require(‘fs’);<br>          app.get(‘./listUsers’, function (req, res){<br>            fs.readFile(__dirname + “/“ + “users.Json”, ‘utf8’, function (err, data){<br>              console.log(data);<br>              res.end(data);<br>            });<br>          });<br>          var server = app.listen(8081, function(){<br>            var host = server.address().address;<br>            var port = server.address().port;<br>            console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)<br>          });<br>        //接下来执行以下命令：<br>          node server.js<br>          应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>        //在浏览器中访问 <a href="http://127.0.0.1:8081/listUsers，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/listUsers，结果如下所示：</a><br>          {<br>             “user1” : {<br>                “name” : “mahesh”,<br>                “password” : “password1”,<br>                “profession” : “teacher”,<br>                “id”: 1<br>             },<br>             “user2” : {<br>                “name” : “suresh”,<br>                “password” : “password2”,<br>                “profession” : “librarian”,<br>                “id”: 2<br>             },<br>             “user3” : {<br>                “name” : “ramesh”,<br>                “password” : “password3”,<br>                “profession” : “clerk”,<br>                “id”: 3<br>             }<br>          }<br>      /</em>添加用户：addUser<em>/<br>        //创建 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示：<br>          var express = require(‘express’);<br>          var app = express();<br>          var fs = require(‘fs’);<br>          //添加的新用户数据<br>          var user = {<br>            “user4” : {<br>                “name” : “mohit”,<br>                “password” : “password4”,<br>                “profession” : “teacher”,<br>                “id”: 4<br>            }<br>          };<br>          app.get(‘./addUser’, function (req, res){<br>            //读取已存在的数据<br>            fs.readFile(__dirname + “/“ + “users.Json”, ‘utf8’, function (err, data){<br>              data = JSON.parse(data);<br>              data[“user4”] = user[“user4”];<br>              console.log(data);<br>              res.end(JSON.stringify(data));<br>            });<br>          });<br>          var server = app.listen(8081, function(){<br>            var host = server.address().address;<br>            var port = server.address().port;<br>            console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)<br>          });<br>        //接下来执行以下命令：<br>          node server.js<br>          应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>        // 在浏览器中访问 <a href="http://127.0.0.1:8081/addUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/addUser，结果如下所示：</a><br>          { user1:<br>             { name: ‘mahesh’,<br>               password: ‘password1’,<br>               profession: ‘teacher’,<br>               id: 1 },<br>            user2:<br>             { name: ‘suresh’,<br>               password: ‘password2’,<br>               profession: ‘librarian’,<br>               id: 2 },<br>            user3:<br>             { name: ‘ramesh’,<br>               password: ‘password3’,<br>               profession: ‘clerk’,<br>               id: 3 },<br>            user4:<br>             { name: ‘mohit’,<br>               password: ‘password4’,<br>               profession: ‘teacher’,<br>               id: 4 }<br>          }<br>      /</em>删除用户：deleteUser<em>/<br>        //创建 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：<br>          var express = require(‘express’);<br>          var app = express();<br>          var fs = require(‘fs’);<br>          app.get(‘./deleteUser’, function (req, res){<br>            //读取已存在的数据<br>            fs.readFile(__dirname + “/“ + “users.Json”, ‘utf8’, function (err, data){<br>              data = JSON.parse(data);<br>              delete data[“user”+2];<br>              console.log(data);<br>              res.end(JSON.stringify(data));<br>            });<br>          });<br>          var server = app.listen(8081, function(){<br>            var host = server.address().address;<br>            var port = server.address().port;<br>            console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)<br>          });<br>        //接下来执行以下命令：<br>          node server.js<br>          应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>        // 在浏览器中访问 <a href="http://127.0.0.1:8081/deleteUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/deleteUser，结果如下所示：</a><br>          { user1:<br>             { name: ‘mahesh’,<br>               password: ‘password1’,<br>               profession: ‘teacher’,<br>               id: 1 },<br>            user3:<br>             { name: ‘ramesh’,<br>               password: ‘password3’,<br>               profession: ‘clerk’,<br>               id: 3 },<br>          }<br>      /</em>显示用户详情：:id(用户id)*/<br>        //创建 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示：<br>          var express = require(‘express’);<br>          var app = express();<br>          var fs = require(‘fs’);<br>          app.get(‘./:id’, function (req, res){<br>            //读取已存在的数据<br>            fs.readFile(__dirname + “/“ + “users.Json”, ‘utf8’, function (err, data){<br>              data = JSON.parse(data);<br>              var user = data[“user” + req.params.id]<br>              console.log(user);<br>              res.end(JSON.stringify(user));<br>            });<br>          });<br>          var server = app.listen(8081, function(){<br>            var host = server.address().address;<br>            var port = server.address().port;<br>            console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)<br>          });<br>        //接下来执行以下命令：<br>          node server.js<br>          应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>        // 在浏览器中访问 <a href="http://127.0.0.1:8081/2，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/2，结果如下所示：</a><br>          {<br>             “name”:”suresh”,<br>             “password”:”password2”,<br>             “profession”:”librarian”,<br>             “id”:2<br>          }</p>
<p>/17、Node.js 多进程<em>/<br>    // 我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。<br>    //Node 提供了 child_process 模块来创建子进程，方法有：<br>      exec - child_process.exec//使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。<br>      spawn - child_process.spawn//使用指定的命令行参数创建新线程。<br>      fork - child_process.fork//是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。<br>    /</em>exec()方法<em>/<br>      //child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。语法如下所示：<br>        child_process.exec(command[, options], callback)<br>      //参数说明如下：<br>        command//字符串， 将要运行的命令，参数使用空格隔开<br>        options//对象，可以是：<br>          /</em>cwd ，字符串，子进程的当前工作目录<br>            env，对象 环境变量键值对<br>            encoding ，字符串，字符编码（默认： ‘utf8’）<br>            shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为/bin/sh， 在 Windows 中为cmd.exe， Shell 应当能识别 -c开关在 UNIX 中，或 /s /c 在 Windows 中。 在Windows 中，命令行解析应当能兼容cmd.exe）<br>            timeout，数字，超时时间（默认： 0）<br>            maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 200<em>1024）<br>            killSignal ，字符串，结束信号（默认：’SIGTERM’）<br>            uid，数字，设置用户进程的 ID<br>            gid，数字，设置进程组的 ID</em>/<br>        callback//回调函数，包含三个参数error, stdout 和 stderr。<br>      //exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。<br>    /<em>实例</em>/<br>      //让我们创建两个 js 文件 support.js 和 master.js。<br>        //support.js 文件代码：<br>          console.log(“进程 “ + process.argv[2] + “ 执行。” );<br>        //master.js 文件代码：<br>          const fs = require(‘fs’);<br>          const child_process = require(‘child_process’);<br>          for (var i = 0; i &lt; 3; i++) {<br>            var workerProcess = child_process.exec(‘node support.js’ + i, function (error, stdout, stderr){<br>              if (error) {<br>                console.log(error.stack);<br>                console.log(‘Error code: ‘ + error.code);<br>                console.log(‘Signal received: ‘ + error.signal);<br>              }<br>              console.log(‘stdout: ‘ + stdout);<br>              console.log(‘stderr: ‘ + stderr);<br>            });<br>            workerProcess.on(‘exit’, function (code){<br>              console.log(‘子进程已退出，退出码 ‘ + code);<br>            });<br>          };<br>        //执行以上代码，结果如下所示：<br>          node master.js<br>          子进程已退出，退出码 0<br>          stdout: 进程 1 执行。</p>
<pre><code>      stderr: 
      子进程已退出，退出码 0
      stdout: 进程 0 执行。

      stderr: 
      子进程已退出，退出码 0
      stdout: 进程 2 执行。

      stderr: 
/*spawn() 方法*/
  //child_process.spawn 使用指定的命令行参数创建新线程，语法格式如下：
    child_process.spawn(command[, args][, options])
  //参数说明如下：
    command //将要运行的命令
    args // Array 字符串参数数组
    options //Object
      /*cwd String 子进程的当前工作目录
        env Object 环境变量键值对
        stdio Array|String 子进程的 stdio 配置
        detached Boolean 这个子进程将会变成进程组的领导
        uid Number 设置用户进程的 ID
        gid Number 设置进程组的 ID*/
  //spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。
/*实例*/
  //让我们创建两个 js 文件 support.js 和 master.js。
    //support.js 文件代码：
      console.log(&quot;进程 &quot; + process.argv[2] + &quot; 执行。&quot; );
    //master.js 文件代码：
      const fs = require(&apos;fs&apos;);
      const child_process = require(&apos;child_process&apos;);
      for (var i = 0; i &lt; 3; i++) {
        var workerProcess = child_process.spawn(&apos;node&apos;, [&apos;support.js&apos;, i]);
        workerProcess.stdout.on(&apos;data&apos;, function (data){
          console.log(&apos;stdout: &apos; + data);
        });
        workerProcess.stderr.on(&apos;data&apos;, function (data){
          console.log(&apos;stderr: &apos; + data);
        }); 
        workerProcess.on(&apos;close&apos;, function (data){
          console.log(&apos;子进程已退出，退出码&apos; + code);
        });         
      };
    //执行以上代码，输出结果为：
      node master.js stdout: 进程 0 执行。

      子进程已退出，退出码 0
      stdout: 进程 1 执行。

      子进程已退出，退出码 0
      stdout: 进程 2 执行。

      子进程已退出，退出码 0
/*fork 方法*/
  //child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：
    child_process.fork(modulePath[, args][, options])
  //参数说明如下：
    modulePath//String，将要在子进程中运行的模块
    args// Array 字符串参数数组
    options//Object
      /*cwd String 子进程的当前工作目录
        env Object 环境变量键值对
        execPath String 创建子进程的可执行文件
        execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv）
        silent Boolean 如果为true，子进程的stdin，stdout和stderr将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：false）
        uid Number 设置用户进程的 ID
        gid Number 设置进程组的 ID*/
  //返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。
/*实例*/
  //让我们创建两个 js 文件 support.js 和 master.js。
    //support.js文件，代码如下：
      console.log(&quot;进程&quot; + process.argv[2] + &quot;执行。&quot;);
    //master.js文件，代码如下：
      const fs = require(&apos;fs&apos;);
      const child_process = require(&apos;child_process&apos;);
      for (var i = 0; i &lt; 3; i++) {
        var worker_process = child_process.fork(&quot;support.js&quot;, [i]);
        worker_process.on(&apos;close&apos;, function (code){
          console.log(&apos;子进程已退出，退出码&apos; + code);
        });
      };
    //执行以上代码，输出结果为：
      node master.js 
      进程 0 执行。
      子进程已退出，退出码 0
      进程 1 执行。
      子进程已退出，退出码 0
      进程 2 执行。
      子进程已退出，退出码 0
</code></pre><p>/18、Node.js JXcore 打包<em>/<br>    //JXcore 是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。但我们这篇文章主要是要教大家介绍 JXcore 的打包功能。<br>    /</em>JXcore 安装<em>/<br>      //下载 JXcore 安装包，并解压，在解压的的目录下提供了 jx 二进制文件命令，接下来我们主要使用这个命令。<br>      //步骤1、下载<br>        //下载 JXcore 安装包 <a href="http://jxcore.com/downloads/，你需要根据你自己的系统环境来下载安装包。" target="_blank" rel="external">http://jxcore.com/downloads/，你需要根据你自己的系统环境来下载安装包。</a><br>        //2、Linux/OSX 下载安装命令，直接下载解压包下的 jx 二进制文件拷贝到 /usr/bin 目录下：<br>          $ wget <a href="https://s3.amazonaws.com/nodejx/jx_rh64.zip" target="_blank" rel="external">https://s3.amazonaws.com/nodejx/jx_rh64.zip</a><br>          $ unzip jx_rh64.zip<br>          $ cp jx_rh64/jx /usr/bin<br>        //将 /usr/bin 添加到 PATH 路径中：<br>          $ export PATH=$PATH:/usr/bin<br>        //以上步骤如果操作正确，使用以下命令，会输出版本号信息：<br>          $ jx –version<br>          v0.10.32<br>    /</em>包代码<em>/<br>      //例如，我们的 Node.js 项目包含以下几个文件，其中 index.js 是主文件：<br>        drwxr-xr-x  2 root root  4096 Nov 13 12:42 images<br>        -rwxr-xr-x  1 root root 30457 Mar  6 12:19 index.htm<br>        -rwxr-xr-x  1 root root 30452 Mar  1 12:54 index.js<br>        drwxr-xr-x 23 root root  4096 Jan 15 03:48 node_modules<br>        drwxr-xr-x  2 root root  4096 Mar 21 06:10 scripts<br>        drwxr-xr-x  2 root root  4096 Feb 15 11:56 style<br>      //接下来我们使用 jx 命令打包以上项目，并指定 index.js 为 Node.js 项目的主文件：<br>        $ jx package index.js index<br>      //以上命令执行成功，会生成以下两个文件：<br>        index.jxp //这是一个中间件文件，包含了需要编译的完整项目信息。<br>        index.jx  //这是一个完整包信息的二进制文件，可运行在客户端上。<br>    /</em>载入 JX 文件*/<br>      //我们使用 jx 命令打包项目：<br>        $ node index.js command_line_arguments<br>      //使用 JXcore 编译后，我们可以使用以下命令来执行生成的 jx 二进制文件：<br>        $ jx index.jx command_line_arguments<br>      //更多 JXcore 功能特性你可以参考官网：<a href="http://jxcore.com/" target="_blank" rel="external">http://jxcore.com/</a></p>

              </div>
              <footer class="article-footer">
                
                <a data-url="http://chaooo.github.io/2016/06/27/NodeJs学习笔记.html" data-id="cipxi2qa9000904ta4x6ew1kh" class="article-share-link">Share</a>
                
                              
              </footer>
            </div>
            
          </article>
          
  
          <article id="post-Hexo博客优化--站内搜索、版权、IE8兼容" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html" class="article-date">
                <time datetime="2016-05-25T02:03:15.000Z" itemprop="datePublished">2016-05-25</time>
              </a> 
            </div>
            <div class="article-inner">
              
              <header class="article-header">                
                <h1 itemprop="name">
                  <a class="article-title" href="/2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html">Hexo博客优化——站内搜索、版权、IE8兼容</a>
                </h1>
                
              </header>
              
              <div class="article-entry" itemprop="articleBody">
                <h3 id="1-添加Hexo的swiftype站内搜索"><a href="#1-添加Hexo的swiftype站内搜索" class="headerlink" title="1.添加Hexo的swiftype站内搜索"></a>1.添加Hexo的swiftype站内搜索</h3><p>先去<a href="https://swiftype.com">swiftype官网</a>注册一个账号,然后根据指引建立好自己网站对应的索引。<br>步骤：<br>     <code>Create an engine</code><br>—&gt; <code>Create a search engine &gt;(standard web crawler)</code><br>—&gt; <code>WEBSITE URL</code>下填写你的网站地址：如：<a href="http://chaooo.github.io">http://chaooo.github.io</a><br>—&gt; <code>ENGINE NAME</code>自己取一个名字：如：chaooo<br>—&gt; 然后他开始抓取你网站的数据。<br>—&gt; 完成后，可以点击<code>Content</code>去看看抓了些什么数据，然后可以自己删除不想要的数据。（可选）<br>—&gt; 点击<code>Install Search</code>复制里面的代码：</p>
<p>然后在<code>themes\landscape\layout\_partial\after-footer.ejs</code>在最后加上刚复制的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">w,d,t,u,n,s,e</span>)</span>&#123;w[<span class="string">'SwiftypeObject'</span>]=n;w[n]=w[n]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(<span class="built_in">arguments</span>);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[<span class="number">0</span>];s.async=<span class="number">1</span>;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">'script'</span>,<span class="string">'//s.swiftypecdn.com/install/v2/st.js'</span>,<span class="string">'_st'</span>); </span><br><span class="line"></span><br><span class="line">  _st(<span class="string">'install'</span>,<span class="string">'Hvy4-e-Ew4x8PR6Let84'</span>,<span class="string">'2.0.0'</span>);</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
                
                <p class="article-more-link">
                  <a href="/2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html#more">阅读全文</a>
                </p>
              </div>
              <footer class="article-footer">
                
                <a data-url="http://chaooo.github.io/2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html" data-id="cipxi2qa0000304tatpieuwbs" class="article-share-link">Share</a>
                
                              
              </footer>
            </div>
            
          </article>
          
  
          <article id="post-Hexo博客优化--库、字体、收录、统计" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2016/05/24/Hexo博客优化--库、字体、收录、统计.html" class="article-date">
                <time datetime="2016-05-24T03:22:56.000Z" itemprop="datePublished">2016-05-24</time>
              </a> 
            </div>
            <div class="article-inner">
              
              <header class="article-header">                
                <h1 itemprop="name">
                  <a class="article-title" href="/2016/05/24/Hexo博客优化--库、字体、收录、统计.html">Hexo博客优化——库、字体、收录、统计</a>
                </h1>
                
              </header>
              
              <div class="article-entry" itemprop="articleBody">
                <h3 id="1-jQuery-库的优化"><a href="#1-jQuery-库的优化" class="headerlink" title="1. jQuery 库的优化"></a>1. jQuery 库的优化</h3><p>landscape默认是使用Google jQuery 库，但在国内速度不是很理想，这里把它换成新浪的，在<code>themes\landscape\layout\_partial\after-footer.ejs</code>17行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>替换为如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">//&lt;![CDATA[</span><br><span class="line"><span class="keyword">if</span> (typeof jQuery == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  document.write(unescape(<span class="string">"%3Cscript src='/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E"</span>));</span><br><span class="line">&#125;</span><br><span class="line">// ]]&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里不但将 Google 的 jQuery 替换成了 SAE 的，随后还进行了一个判断，如果获取新浪的 jQuery 失败，则使用本网站自己的 jQuery。为了让这段代码有效，我们要去 jQuery 官方下载合适版本的 jQuery 并将其放到 <code>themes/landscape/source/js/</code>目录下，命名为 <code>jquery-2.0.3.min.js</code>。<br>
                
                <p class="article-more-link">
                  <a href="/2016/05/24/Hexo博客优化--库、字体、收录、统计.html#more">阅读全文</a>
                </p>
              </div>
              <footer class="article-footer">
                
                <a data-url="http://chaooo.github.io/2016/05/24/Hexo博客优化--库、字体、收录、统计.html" data-id="cipxi2q9w000104tal45tcip8" class="article-share-link">Share</a>
                
                              
                <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
              
              </footer>
            </div>
            
          </article>
          
  
          <article id="post-Hexo博客优化--主题、分享、评论、微博秀" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html" class="article-date">
                <time datetime="2016-05-23T06:30:13.000Z" itemprop="datePublished">2016-05-23</time>
              </a> 
            </div>
            <div class="article-inner">
              
              <header class="article-header">                
                <h1 itemprop="name">
                  <a class="article-title" href="/2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html">Hexo博客优化——主题、分享、评论、微博秀</a>
                </h1>
                
              </header>
              
              <div class="article-entry" itemprop="articleBody">
                <p>继上一篇<a href="Hexo3-2-github搭建静态博客.html">Hexo3.2+GitHub搭建静态博客</a>。</p>
<h3 id="1-主题"><a href="#1-主题" class="headerlink" title="1.主题"></a>1.主题</h3><p>Hexo提供了很多主题，具体可参见<a href="https://hexo.io/themes/">Themes|Hexo</a>，这里我选择默认主题<a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a>(此主题默认已安装)。</p>
<h4 id="1-1安装主题"><a href="#1-1安装主题" class="headerlink" title="1.1安装主题"></a>1.1安装主题</h4><p>将Git Shell切换到根目录，执行下列命令，将主题下载到themes/spfk目录下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/hexojs/hexo-theme-landscape.git themes/landscape</span><br></pre></td></tr></table></figure></p>
<p>获取landscape主题的最新版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/landscape</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<p>修改在根目录下_config.yml 配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: landscape</span><br></pre></td></tr></table></figure></p>
<h3 id="2-修改添加分享链接"><a href="#2-修改添加分享链接" class="headerlink" title="2.修改添加分享链接"></a>2.修改添加分享链接</h3><h4 id="2-1原生分享的修改"><a href="#2-1原生分享的修改" class="headerlink" title="2.1原生分享的修改"></a>2.1原生分享的修改</h4><p>在<code>themes\landscape\source\js\script.js</code>中，57行 <code>&lt;div class=&quot;article-share-links&quot;&gt;</code>下面的四个链接就是 Facebook 等社交网站的分享链接。将其替换或添加如下代码，即可实现分享到国内社交网站：<br>
                
                <p class="article-more-link">
                  <a href="/2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html#more">阅读全文</a>
                </p>
              </div>
              <footer class="article-footer">
                
                <a data-url="http://chaooo.github.io/2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html" data-id="cipxi2qa1000404tay744azyf" class="article-share-link">Share</a>
                
                              
                <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
              
              </footer>
            </div>
            
          </article>
          
  
          <article id="post-Hexo3-2-github搭建静态博客" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2016/05/23/Hexo3-2-github搭建静态博客.html" class="article-date">
                <time datetime="2016-05-23T03:16:51.000Z" itemprop="datePublished">2016-05-23</time>
              </a> 
            </div>
            <div class="article-inner">
              
              <header class="article-header">                
                <h1 itemprop="name">
                  <a class="article-title" href="/2016/05/23/Hexo3-2-github搭建静态博客.html">Hexo3.2+GitHub搭建静态博客</a>
                </h1>
                
              </header>
              
              <div class="article-entry" itemprop="articleBody">
                <h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装<a href="https://hexo.io/zh-cn/">hexo</a>之前，必须确认你已经安装了<a href="http://nodejs.org/">Node.js</a>和<a href="http://git-scm.com/">Git</a>。</p>
<h4 id="1-创建GitHub仓库"><a href="#1-创建GitHub仓库" class="headerlink" title="1.创建GitHub仓库"></a>1.创建GitHub仓库</h4><p>注册<a href="https://github.com/">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href="https://github.com/chaooo/chaooo.github.io">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>
<h4 id="2-配置Git"><a href="#2-配置Git" class="headerlink" title="2.配置Git"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-本地Git与GitHub建立联系"><a href="#3-本地Git与GitHub建立联系" class="headerlink" title="3.本地Git与GitHub建立联系"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure></p>
<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：<br>
                
                <p class="article-more-link">
                  <a href="/2016/05/23/Hexo3-2-github搭建静态博客.html#more">阅读全文</a>
                </p>
              </div>
              <footer class="article-footer">
                
                <a data-url="http://chaooo.github.io/2016/05/23/Hexo3-2-github搭建静态博客.html" data-id="cipxi2q9s000004ta024qllsr" class="article-share-link">Share</a>
                
                              
                <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
              
              </footer>
            </div>
            
          </article>
          
  


        </section>
          <aside id="sidebar">            
            
              
              <div class="widget-wrap">
                <h3 class="widget-title">标签</h3>
                <div class="widget">
                  <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
                </div>
              </div>               
              <div class="widget-wrap">
                <h3 class="widget-title">归档</h3>
                <div class="widget">
                  <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li></ul>
                </div>
              </div> 
              
              
              <div class="widget-wrap">
                <h3 class="widget-title">标签云</h3>
                <div class="widget tagcloud">
                  <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a>
                </div>
              </div> 
                            
              <div class="widget-wrap">
                <h3 class="widget-title">最新文章</h3>
                <div class="widget">
                  <ul>
                    <li>
                        <a href="/2016/06/27/NodeJs学习笔记.html">NodeJs学习笔记</a>
                    </li><li>
                        <a href="/2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html">Hexo博客优化——站内搜索、版权、IE8兼容</a>
                    </li><li>
                        <a href="/2016/05/24/Hexo博客优化--库、字体、收录、统计.html">Hexo博客优化——库、字体、收录、统计</a>
                    </li><li>
                        <a href="/2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html">Hexo博客优化——主题、分享、评论、微博秀</a>
                    </li><li>
                        <a href="/2016/05/23/Hexo3-2-github搭建静态博客.html">Hexo3.2+GitHub搭建静态博客</a>
                    </li>
                  </ul>
              </div>
                            
              <div class="widget-wrap">
                <h3 class="widget-title">微博</h3>
                <div class="widget" style="padding: 0">
                  <iframe width="100%" height="400" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=2&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,dddddd,555555,837f86,cccccc&dpc=1"></iframe>
                </div>
              </div>
              
          </aside> 
      </div>
      <!--[if lt IE 9]><div id="footer"><![endif]-->
      <footer id="footer">
        
        <div class="outer">
          <div id="footer-info" class="inner" style="text-align:center;">
            Copyright &copy; 2016 郑超(Charles)<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br>
            <a href="/baidusitemap.xml">网站地图</a>&nbsp; &nbsp;|&nbsp; &nbsp;<a href="/atom.xml">订阅本站</a>&nbsp; &nbsp;|&nbsp; &nbsp;<a href="mailto:zhenggchaoo@gmail.com" target="_blank">联系博主</a>           
          </div>
        </div>
      </footer>
      <!--[if lt IE 9]></div><![endif]-->

    </div>
    <nav id="mobile-nav">
        <a href="/" class="mobile-nav-link">Home</a>  <a href="/archives" class="mobile-nav-link">Archives</a>  <a href="/baidusitemap.xml" class="mobile-nav-link">baidusitemap</a> 
    </nav>
    <script src="http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js"></script>
    <script type="text/javascript">
    //<![CDATA[
    if (typeof jQuery == 'undefined') {
      document.write(unescape("%3Cscript src='/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E"));
    }
    // ]]>
    </script>
     
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
    <script src="/fancybox/jquery.fancybox.pack.js"></script> 
    
    <!-- Swiftype Search Start -->
    <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');  
      _st('install','Hvy4-e-Ew4x8PR6Let84','2.0.0');
    </script>
    <!-- Swiftype Search End -->
    <!-- Google Analytics -->
    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-78287143-1', 'auto');
    ga('send', 'pageview');
    </script>
    <!-- End Google Analytics -->
    <!-- Baidu Share Start -->
    <script>window._bd_share_config={"common":{"bdSnsKey":{"tsina":"2524825","tqq":"294a84f647b3e69c5cdc3d8a77f1c927"},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
    <!-- Baidu Share End -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">var duoshuoQuery = {short_name:"chaooo"};(function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true;  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);})();</script>
    <!-- 多说公共JS代码 end -->
    <script>(function(){var bp = document.createElement('script');var curProtocol = window.location.protocol.split(':')[0];if (curProtocol === 'https') {bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';}else {bp.src = 'http://push.zhanzhang.baidu.com/push.js';}var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp, s);})();</script>

    <script src="/js/script.js"></script>
  </div>
</body>
</html>